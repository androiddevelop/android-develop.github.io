<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小胖轩</title>
    <description>编码生涯的点点滴滴</description>
    <link>https://https://www.codeboy.me/</link>
    <atom:link href="https://https://www.codeboy.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 27 Jun 2019 00:33:50 +0800</pubDate>
    <lastBuildDate>Thu, 27 Jun 2019 00:33:50 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Javascript的undefined和null</title>
        <description>&lt;p&gt;Javascript中的 &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 非常的常见，它们有什么不同呢？首先看几个简单的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;var a = undefined;
var b = null;
console.log(a == b);
console.log(a === b);
console.log(typeof(a) == typeof(b));
console.log(a + 1);
console.log(b + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的5个console日志会输出什么？&lt;/p&gt;

&lt;h3 id=&quot;解析&quot;&gt;解析&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;undefined&lt;/code&gt; 在javascript中表示一个没有设置值的变量， &lt;code&gt;null&lt;/code&gt; 表示一个空对象引用。从表示含义上可以很清楚的区分两者， 不过两者在部分使用上有一些差异，如下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特征&lt;/th&gt;
      &lt;th&gt;undefined&lt;/th&gt;
      &lt;th&gt;null&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;含义&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
      &lt;td&gt;空对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示数据&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;类型&lt;/td&gt;
      &lt;td&gt;undefined&lt;/td&gt;
      &lt;td&gt;object&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以上几个示例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;var a = undefined;
var b = null;
console.log(a == b);   // true
console.log(a === b);   // false
console.log(typeof(a) == typeof(b));   // false
console.log(a + 1);    // NaN
console.log(b + 1);  // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对这两个的经典场景，在阮一峰老师的文章&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html&quot;&gt;undefined与null的区别&lt;/a&gt;中给出了说明，这里引用一下。&lt;/p&gt;

&lt;h4 id=&quot;null典型用法&quot;&gt;null典型用法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;undefined典型用法&quot;&gt;undefined典型用法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;（1）变量被声明了，但没有赋值时，就等于undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
（3）对象没有赋值的属性，该属性的值为undefined。
（4）函数没有返回值时，默认返回undefined。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 在javascript中的含义相近，存在差异， &lt;code&gt;undefined&lt;/code&gt; 的场景更多一些。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 17 Jun 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/06/17/js-undefined-and-null/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/06/17/js-undefined-and-null/</guid>
        
        <category>web</category>
        
        
      </item>
    
      <item>
        <title>Java源码在线编译执行</title>
        <description>&lt;p&gt;在告警平台中，经常会用到规则配置，一些简单的规则配置可以使用基本表达式来完成，对于一些复杂的规则，很难进行表达或者完全覆盖，如果告警规则等由一些具备编程能力的开发同学来完成，是否可以考虑规则直接使用源码来描述，动态执行呢？这样可以在系统不重新部署的情况下加入新的规则配置。&lt;/p&gt;

&lt;p&gt;下面我们根据 &lt;code&gt;JDK6&lt;/code&gt; 中新增的 &lt;code&gt;JavaCompiler&lt;/code&gt; ，来实现源码线上编译，完成简单类的线上运行，并获取对应的结果。&lt;/p&gt;

&lt;h3 id=&quot;约定&quot;&gt;约定&lt;/h3&gt;

&lt;p&gt;约定测试类需要实现无参 &lt;code&gt;execute&lt;/code&gt; 方法，在编译成功后，使用反射的方法调用该方法。下面是我们用来测试的一个代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.compile;

/**
 * 测试class
 * Created by yuedong.li on 2019-06-14
 */
public class FooClass {

    public String execute() {
        System.out.println(&quot;invoke method&quot;);
        return &quot;SUCCESS&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印 &lt;code&gt;invoke method&lt;/code&gt; , 并返回对应 &lt;code&gt;SUCCESS&lt;/code&gt; 结果。&lt;/p&gt;

&lt;h3 id=&quot;准备&quot;&gt;准备&lt;/h3&gt;

&lt;p&gt;编译java代码需要指定编译参数和classpath，使用 &lt;code&gt;JavaCompiler&lt;/code&gt; 也是一样的，需要把执行测试类的一些基础依赖添加到编译环境中来，针对本文中的示例，使用基本配置即可，作者测试时使用的配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  编译参数:  -target 1.8
classpath: 工程中的其他的class作为classpath
  输出目录: 工程根目录下的CodeTest目录
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;实施&quot;&gt;实施&lt;/h3&gt;

&lt;h4 id=&quot;定义javafileobject&quot;&gt;定义JavaFileObject&lt;/h4&gt;

&lt;p&gt;用于保存源码，jdk中提供了 &lt;code&gt;SimpleJavaFileObject&lt;/code&gt; , 可以在该类的基础上简单修改即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.compile;

import javax.tools.SimpleJavaFileObject;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.net.URI;

/**
 * java file object
 * Created by yuedong.li on 2019-06-13
 */
public class MyJavaFileObject extends SimpleJavaFileObject {
    private String source;

    public MyJavaFileObject(String name, String source) {
        super(URI.create(&quot;String:///&quot; + name + Kind.SOURCE.extension), Kind.SOURCE);
        this.source = source;
    }

    @Override
    public CharSequence getCharContent(boolean ignoreEncodingErrors) {
        if (source == null) {
            throw new IllegalArgumentException(&quot;source == null&quot;);
        }
        return source;
    }

    @Override
    public OutputStream openOutputStream() {
        return new ByteArrayOutputStream();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;定义classloader&quot;&gt;定义classloader&lt;/h4&gt;

&lt;p&gt;加载字节码，为什么定义呢，因为 &lt;code&gt;defineClass&lt;/code&gt; 是 &lt;code&gt;protected&lt;/code&gt; 修饰的, 实际上是做一个中转。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.compile;

/**
 * classLoader，在当前classLoader的基础上，load进来自己载入的类
 * Created by yuedong.li on 2019-06-13
 */
public class MyClassLoader extends ClassLoader {

    public MyClassLoader() {
        super(MyClassLoader.class.getClassLoader());
    }

    Class&amp;lt;?&amp;gt; getTestClass(byte[] classBytes) {
        return defineClass(null, classBytes, 0, classBytes.length);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;coderuntime&quot;&gt;CodeRuntime&lt;/h4&gt;

&lt;p&gt;源码执行器，进行的操作如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;源码去除package头部&lt;/li&gt;
  &lt;li&gt;获取className&lt;/li&gt;
  &lt;li&gt;为生成的class指定目录&lt;/li&gt;
  &lt;li&gt;编译源码，生成字节码&lt;/li&gt;
  &lt;li&gt;加载字节码，反射调用execute方法&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.compile;

import javax.tools.*;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * code runtime
 * Created by yuedong.li on 2019/06/14.
 */
public class CodeRuntime {
    private static final Pattern CLASS_PATTERN = Pattern.compile(&quot;class\\s+([$_a-zA-Z][$_a-zA-Z0-9]*)\\s*&quot;);
    private static final List&amp;lt;String&amp;gt; OPTIONS = new ArrayList&amp;lt;&amp;gt;(); // 编译参数
    private static final List&amp;lt;File&amp;gt; CLASSPATH = new ArrayList&amp;lt;&amp;gt;(); // classpath
    private static final String PROJECT_DIR = System.getProperty(&quot;user.dir&quot;); // 工程目录
    private static final String TMP_DIR = &quot;CodeTest&quot;; // 存储编译产物

    static {
        OPTIONS.add(&quot;-target&quot;);
        OPTIONS.add(&quot;1.8&quot;);
        File classRootFile = new File(PROJECT_DIR, TMP_DIR);
        if (!classRootFile.exists()) {
            classRootFile.mkdir();
        }
        //根据实际情况添加对应的环境变量，class或者jar都可以
        CLASSPATH.add(new File(classRootFile, &quot;build/classes/main&quot;));
    }

    /**
     * 执行代码
     *
     * @param code 源码
     * @return 返回结果
     * @throws IOException io异常
     */
    public static String run(String code) throws IOException {
        if (code == null || code.length() == 0) {
            return &quot;代码为空&quot;;
        }
        code = code.trim();
        //去除package
        if (code.startsWith(&quot;package&quot;)) {
            int index = code.indexOf(&quot;\n&quot;);
            if (index != -1) {
                code = code.substring(index + 1);
            }
        }

        //找出入口类名
        Matcher matcher = CLASS_PATTERN.matcher(code);
        String clsName;
        if (matcher.find()) {
            clsName = matcher.group(1);
        } else {
            throw new IllegalArgumentException(&quot;No such class name in &quot; + code);
        }

        //在对应代码生成目录中以时间戳为目录名建立目录
        File classRootFile = new File(PROJECT_DIR, TMP_DIR);
        final String time = String.valueOf(System.currentTimeMillis());
        File parentDir = new File(classRootFile, time);
        if (!parentDir.exists()) {
            parentDir.mkdir();
        }

        File classFile = new File(parentDir, clsName + &quot;.class&quot;);
        File[] outputs = new File[]{parentDir};

        //开始进行编译
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        DiagnosticCollector&amp;lt;JavaFileObject&amp;gt; collector = new DiagnosticCollector&amp;lt;&amp;gt;();
        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);
        fileManager.setLocation(StandardLocation.CLASS_PATH, CLASSPATH);
        fileManager.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(outputs));

        JavaFileObject javaFileObject = new MyJavaFileObject(clsName, code);
        Boolean result = compiler.getTask(null, fileManager, collector, OPTIONS, null, Arrays.asList(javaFileObject)).call();
      
        //编译结果，如果有错误，返回对应错误信息
        if (!result) {
            List list = collector.getDiagnostics();
            StringBuilder info = new StringBuilder();
            for (Object object : list) {
                Diagnostic d = (Diagnostic) object;
                String line = d.getMessage(Locale.ENGLISH);
                info.append(line).append(&quot;\n&quot;);
            }
            String infoStr = info.toString();
            if (infoStr.endsWith(&quot;\n&quot;)) {
                infoStr = infoStr.substring(0, infoStr.length() - 1);
            }
            return &quot;编译失败:&quot; + infoStr;
        }

        //读取字节码，使用类加载器加载
        byte[] classBytes = getBytesFromFile(classFile);
        MyClassLoader classloader = new MyClassLoader();
        try {
            Class clazz = classloader.getTestClass(classBytes);
            Object instance = clazz.newInstance();

            Method method = clazz.getMethod(&quot;execute&quot;);
            return method.invoke(instance).toString();
        } catch (NoSuchMethodException e) {
            return &quot;请实现execute无参方法&quot;;
        } catch (Exception e2) {
            return e2.getMessage();
        }
    }

    /**
     * 文件转化为字节数组
     *
     * @param file 文件
     * @return 字节数组
     */
    private static byte[] getBytesFromFile(File file) throws IOException {
        if (file == null) {
            return null;
        }
        FileInputStream in = new FileInputStream(file);
        ByteArrayOutputStream out = new ByteArrayOutputStream(4096);
        byte[] b = new byte[4096];
        int n;
        while ((n = in.read(b)) != -1) {
            out.write(b, 0, n);
        }
        in.close();
        out.close();
        return out.toByteArray();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;对 &lt;code&gt;CoideRuntime&lt;/code&gt; 进行源码测试，将 &lt;code&gt;FooTest&lt;/code&gt; 类的源码作为字符串输入后执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  package me.codeboy.test.compile;
  
  import java.io.IOException;
  
  /**
   * 测试代码
   * Created by yuedong.li on 2019-06-13
   */
  public class Test {
      public static void main(String[] args) throws IOException {
          String source = &quot;package me.codeboy.test.compile;&quot; +
                  &quot;\n&quot; +
                  &quot;/**\n&quot; +
                  &quot; * 测试class\n&quot; +
                  &quot; * Created by yuedong.li on 2019-06-14\n&quot; +
                  &quot; */\n&quot; +
                  &quot;public class FooClass { \n&quot; +
                  &quot;    public String execute() {\n&quot; +
                  &quot;        System.out.println(\&quot;invoke method\&quot;);&quot; +
                  &quot;        return \&quot;SUCCESS\&quot;;&quot;+
                  &quot;    }&quot; +
                  &quot;}&quot;;
          String result = CodeRuntime.run(source);
          System.out.println(result);
      }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后，输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;invoke method
SUCCESS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;符合预期结果。&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;根据上面的讲述，针对告警平台等的一些规则可以使用源码来编写，虽然需要一点开发成本，但是灵活度大幅度提升，遇到合适的场景可以考虑尝试。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 14 Jun 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/06/14/java-online-compile/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/06/14/java-online-compile/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>Java字符串单字符分割</title>
        <description>&lt;p&gt;Java中分割字符串经常会使用到 &lt;code&gt;String.split&lt;/code&gt; ，本文中针对单字符分割的场景进行简单讨论，首先看几个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;&quot;&quot;.split(&quot;=&quot;)      //示例1
&quot;=&quot;.split(&quot;=&quot;)     //示例2
&quot;==&quot;.split(&quot;=&quot;)    //示例3
&quot;=&quot;.split(&quot;=&quot;, 1)  //示例4
&quot;=&quot;.split(&quot;=&quot;, 2)  //示例5
&quot;=&quot;.split(&quot;=&quot;, 4)  //示例6
&quot;=12=&quot;.split(&quot;=&quot;)  //示例7
&quot;&quot;.split(&quot;=&quot;, 1)   //示例8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上几个示例分割后的数组长度是多少呢？在本文小结中有结果，可以对比下是否和想象中的一致，有出入的话可以一起来看下源码。&lt;/p&gt;

&lt;h3 id=&quot;源码解析&quot;&gt;源码解析&lt;/h3&gt;

&lt;p&gt;基于jdk8来分析下 &lt;code&gt;String.split&lt;/code&gt; 方法，&lt;code&gt;String.split&lt;/code&gt;  有2个方法，分别如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public String[] split(String regex)   //方法1
public String[] split(String regex, int limit) // 方法2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中方法1直接调用方法2，传入&lt;code&gt;limit=0&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public String[] split(String regex) {
        return split(regex, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面具体看一下方法2的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public String[] split(String regex, int limit) {
  // 针对单字符分割，使用fastpath，没有使用正则java.util.regex.Pattern.split方法
  /* fastpath if the regex is a
    (1)one-char String and this character is not one of the
            RegEx's meta characters &quot;.$|()[{^?*+\\&quot;, or
    (2)two-char String and the first char is the backslash and
            the second is not the ascii digit or ascii letter.
  */
  char ch = 0;
  if (((regex.value.length == 1 &amp;amp;&amp;amp;
        &quot;.$|()[{^?*+\\&quot;.indexOf(ch = regex.charAt(0)) == -1) ||
       (regex.length() == 2 &amp;amp;&amp;amp;
        regex.charAt(0) == '\\' &amp;amp;&amp;amp;
        (((ch = regex.charAt(1))-'0')|('9'-ch)) &amp;lt; 0 &amp;amp;&amp;amp;
        ((ch-'a')|('z'-ch)) &amp;lt; 0 &amp;amp;&amp;amp;
        ((ch-'A')|('Z'-ch)) &amp;lt; 0)) &amp;amp;&amp;amp;
      (ch &amp;lt; Character.MIN_HIGH_SURROGATE ||
       ch &amp;gt; Character.MAX_LOW_SURROGATE))
  {
    int off = 0;
    int next = 0;
    // limit为0表示没有显示最大分割个数
    boolean limited = limit &amp;gt; 0;
    ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    while ((next = indexOf(ch, off)) != -1) {
      // 长度限制为1时，该条件不满足，直接进入else中，也即示例4、8的操作
      if (!limited || list.size() &amp;lt; limit - 1) {
        list.add(substring(off, next));
        off = next + 1;
      } else {    // last one
        //assert (list.size() == limit - 1);
        list.add(substring(off, value.length));
        off = value.length;
        break;
      }
    }
    // 示例1会进入的逻辑，因为示例1在上面的while中会直接跳出，off时默认值0
    // If no match was found, return this
    if (off == 0)
      return new String[]{this};

    //将最后一个添加进来
    // Add remaining segment
    if (!limited || list.size() &amp;lt; limit)
      list.add(substring(off, value.length));

    // 针对limit=0的场景，会循环去除最后一个空字符串，示例2、3会触发该条件
    // 为什么会针对limit=0的这种场景去除空字符串？感觉不能理解。
    // Construct result
    int resultSize = list.size();
    if (limit == 0) {
      while (resultSize &amp;gt; 0 &amp;amp;&amp;amp; list.get(resultSize - 1).length() == 0) {
        resultSize--;
      }
    }
    String[] result = new String[resultSize];
    return list.subList(0, resultSize).toArray(result);
  }
  //多字符串分割本文不讨论
  return Pattern.compile(regex).split(this, limit);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;根据上面的例子, 我们可以看出，在不限定长度的情况下，split分割会去除数据末尾的所有空串。以上几种场景的结果如下:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;结果&lt;/th&gt;
      &lt;th&gt;长度&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;”“.split(“=”)  //示例1&lt;/td&gt;
      &lt;td&gt;[””]&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”=”.split(“=”)  //示例2&lt;/td&gt;
      &lt;td&gt;[]&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”==”.split(“=”)  //示例3&lt;/td&gt;
      &lt;td&gt;[]&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”=”.split(“=”, 1)  //示例4&lt;/td&gt;
      &lt;td&gt;[”=”]&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”=”.split(“=”, 2)  //示例5&lt;/td&gt;
      &lt;td&gt;[””, “”]&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”=”.split(“=”, 4)  //示例6&lt;/td&gt;
      &lt;td&gt;[””, “”]&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“=12=”.split(“=”)  //示例7&lt;/td&gt;
      &lt;td&gt;[””, “12”]&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”“.split(“=”, 1)  //示例8&lt;/td&gt;
      &lt;td&gt;[””]&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 05 Jun 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/06/05/java-string-spilt/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/06/05/java-string-spilt/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>同域代理</title>
        <description>&lt;h3 id=&quot;前沿&quot;&gt;前沿&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;跨域请求&lt;/code&gt; 对于每一个前端开发应该都不会陌生，由于一些安全策略的限制，默认情况下浏览器不允许在一个域下请求另外一个域下的资源，例如 &lt;code&gt;www.codeboy.me&lt;/code&gt; 下请求 &lt;code&gt;test.codeboy.me&lt;/code&gt; 下的资源，相同的域要求协议、域名、端口都必须相同。&lt;/p&gt;

&lt;p&gt;当前解决的方案有以下几种:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-no_highlight&quot;&gt;1. JSONP
2. 同域请求
3. CORS(跨域资源共享)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JSONP&lt;/code&gt; 和 &lt;code&gt;CORS&lt;/code&gt; 均需要服务端进行适当适配和改造，这里不再讲述，感兴趣的小伙伴可以自行查询。这里我们对同域请求的实现进行说明。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;同域请求&lt;/code&gt; ,顾名思义就是将相同域下的请求进行代理，其实是一种 &lt;code&gt;反向代理&lt;/code&gt; , 用最近项目开发中的一个例子来进行叙述和配置。前端页面部署在 &lt;code&gt;project.example.com&lt;/code&gt; 中，服务端代码也部署在该服务器上，但是端口是 &lt;code&gt;9999&lt;/code&gt; , 正常情况下，&lt;code&gt;http://project.example.com/test.html&lt;/code&gt; 页面中是访问不到 &lt;code&gt;http://project.example.com:9999/api/getData&lt;/code&gt; 的数据的，此事我们可以加一层代理，将  &lt;code&gt;http://project.example.com/api/getData&lt;/code&gt; 全部代理转发到  &lt;code&gt;http://project.example.com:9999/api/getData&lt;/code&gt; 即可。&lt;/p&gt;

&lt;h3 id=&quot;准备环境&quot;&gt;准备环境&lt;/h3&gt;

&lt;p&gt;鉴于长期使用 &lt;code&gt;Apache Server&lt;/code&gt; ，本次基于 &lt;code&gt;Apache 2.4.18&lt;/code&gt; 进行，后端所有的接口均有 &lt;code&gt;/api&lt;/code&gt; 开头。&lt;/p&gt;

&lt;h3 id=&quot;期待目标&quot;&gt;期待目标&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;正常访问 &lt;code&gt;http://project.example.com&lt;/code&gt; 可以请求到所有的静态资源&lt;/li&gt;
  &lt;li&gt;所有的 &lt;code&gt;http://project.example.com/api/**&lt;/code&gt; 的请求代理到 &lt;code&gt;http://project.example.com:9999/api/**&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;服务器配置&quot;&gt;服务器配置&lt;/h3&gt;

&lt;p&gt;在原有配置 &lt;code&gt;VirtualHost&lt;/code&gt; 目录中，增加对 &lt;code&gt;/api&lt;/code&gt;  的反向代理，由于同域，可以直接转发到 &lt;code&gt;127.0.0.1&lt;/code&gt; 上即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
	ServerAdmin admin@example.com
  ServerName project.example.com
	DocumentRoot /var/www/example
 
	&amp;lt;Directory /var/www/example&amp;gt;
		Options FollowSymLinks
		AllowOverride None
    Require all granted
	&amp;lt;/Directory&amp;gt;

  ProxyPass /api/ http://127.0.0.1:9999/api/
  ProxyPassReverse /api/ http://127.0.0.1:9999/api/
  ProxyPassReverseCookiePath / /api
	
	LogLevel warn

	CustomLog ${APACHE_LOG_DIR}/access.log combined
&amp;lt;/VirtualHost&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;同域代理&lt;/code&gt; 后，服务端和前端代码都不需要进行修改，完美的解决了问题。最后还要说明的一点是：跨域请求被拒绝是在浏览器(客户端)上进行的，并不是服务端。&lt;/p&gt;

&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53996160&quot;&gt;所有人都应该知道的跨域及CORS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 01 Jun 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/06/01/domain-proxy/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/06/01/domain-proxy/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>Java代理</title>
        <description>&lt;p&gt;代理是在开发中经常用到的一种模式，不暴露真实的对象，取而代之的提供代理对象，在代理对象中可以对实际操作的前后进行一些处理，也即流行的面向切面编程(AOP)，Spring中的拦截器使用的就是代理模式。&lt;/p&gt;

&lt;p&gt;我们对一个需要两步完成的任务，使用普通模式、静态代理、动态代理和cglib分别实现下：&lt;/p&gt;

&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;

&lt;p&gt;定义接口 &lt;code&gt;ITask&lt;/code&gt; 和实现类 &lt;code&gt;Task&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.proxy;

/**
 * 任务
 * Created by yuedong.li on 2019-05-27
 */
public interface ITask {
    /**
     * 步骤一
     */
    public void step1();

    /**
     * 步骤二
     */
    public void step2();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;package me.codeboy.test.proxy;

/**
 * 任务
 * Created by yuedong.li on 2019-05-27
 */
public class Task implements ITask {
    @Override
    public void step1() {
        System.out.println(&quot;step1 print task!!&quot;);
    }

    @Override
    public void step2() {
        System.out.println(&quot;step2 print task!!&quot;);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;普通模式&quot;&gt;普通模式&lt;/h3&gt;

&lt;p&gt;该模式下，创建 &lt;code&gt;Task&lt;/code&gt; 实例后，直接调用对应方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.proxy;

/**
 * 普通模式
 * Created by yuedong.li on 2019-05-27
 */
public class CommonMain {
    public static void main(String[] args) {
        ITask task = new Task();
        task.step1();
        task.step2();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;step1 print task!!
step2 print task!!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;静态代理&quot;&gt;静态代理&lt;/h3&gt;

&lt;p&gt;由一个代理类来进行实际方法调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.proxy;

/**
 * 任务静态代理
 * Created by yuedong.li on 2019-05-27
 */
public class TaskStaticProxy implements ITask {
    private Task task;

    public TaskStaticProxy(Task task) {
        this.task = task;
    }

    @Override
    public void step1() {
        System.out.println(&quot;-----&amp;gt; before step1&quot;);
        task.step1();
        System.out.println(&quot;-----&amp;gt; after step1&quot;);
    }

    @Override
    public void step2() {
        System.out.println(&quot;-----&amp;gt; before step2&quot;);
        task.step2();
        System.out.println(&quot;-----&amp;gt; after step2&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.proxy;

/**
 * 静态代理
 * Created by yuedong.li on 2019-05-27
 */
public class StaticProxyMain {
    public static void main(String[] args) {
        ITask task = new TaskStaticProxy(new Task());
        task.step1();
        task.step2();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;&amp;gt; -----&amp;gt; before step1
&amp;gt; step1 print task!!
&amp;gt; -----&amp;gt; after step1
&amp;gt; -----&amp;gt; before step2
&amp;gt; step2 print task!!
&amp;gt; -----&amp;gt; after step2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;动态代理&quot;&gt;动态代理&lt;/h3&gt;

&lt;p&gt;由Proxy创建一个代理 &lt;code&gt;ITask&lt;/code&gt; 接口的代理来进行实际方法调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 任务动态代理
 * Created by yuedong.li on 2019-05-27
 */
public class TaskDynamicProxy implements InvocationHandler {
    private Task task;

    public TaskDynamicProxy(Task task) {
        this.task = task;
    }

    /**
     * 创建动态代理
     */
    public ITask getProxy() {
        return (ITask) Proxy.newProxyInstance(task.getClass().getClassLoader(), task.getClass().getInterfaces(), this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;-----&amp;gt; before &quot; + method.getName());
        Object ret = method.invoke(task, args); //执行真正的方法
        System.out.println(&quot;-----&amp;gt; after &quot; + method.getName());
        return ret;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.proxy;

/**
 * 动态代理
 * Created by yuedong.li on 2019-05-27
 */
public class DynamicProxyMain {
    public static void main(String[] args) {
        ITask task = new TaskDynamicProxy(new Task()).getProxy();
        task.step1();
        task.step2();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;-----&amp;gt; before step1
step1 print task!!
-----&amp;gt; after step1
-----&amp;gt; before step2
step2 print task!!
-----&amp;gt; after step2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;cglib代理&quot;&gt;cglib代理&lt;/h3&gt;

&lt;p&gt;创建一个代理 &lt;code&gt;Task&lt;/code&gt; 类的代理类来进行实际方法调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.proxy;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * cglib代理
 * Created by yuedong.li on 2019-05-27
 */
public class TaskCglibProxy&amp;lt;T&amp;gt; implements MethodInterceptor {

    /**
     * 获取代理对象
     *
     * @param object 对象
     * @return proxy 对象
     */
    public T getProxy(T object) {
        Enhancer enhancer = new Enhancer(); //创建Enhancer来生成动态代理类
        enhancer.setSuperclass(object.getClass());
        enhancer.setCallback(this);  //设置回调，之后所有的方法调用将会执行intercept方法
        return (T) enhancer.create();
    }

    /**
     * 代理对象的执行会回调到此方法中
     */
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println(&quot;-----&amp;gt; before &quot; + method.getName());
        Object result = proxy.invokeSuper(obj, args); //调用业务类的方法
        System.out.println(&quot;-----&amp;gt; after &quot; + method.getName());
        return result;
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.proxy;

/**
 * cglib代理
 * Created by yuedong.li on 2019-05-27
 */
public class CglibProxyMain {
    public static void main(String[] args) {
        ITask task = new TaskCglibProxy&amp;lt;ITask&amp;gt;().getProxy(new Task());
        task.step1();
        task.step2();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;-----&amp;gt; before step1
step1 print task!!
-----&amp;gt; after step1
-----&amp;gt; before step2
step2 print task!!
-----&amp;gt; after step2
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;根据上面的例子，简单的总结一下几种代理模式的使用场景和特点：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;场景&lt;/th&gt;
      &lt;th&gt;特点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;静态代理&lt;/td&gt;
      &lt;td&gt;代理比较简单的类&lt;/td&gt;
      &lt;td&gt;代理多个方法后会比较繁琐，可能会有很多重复代码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;动态代理&lt;/td&gt;
      &lt;td&gt;代理接口&lt;/td&gt;
      &lt;td&gt;只能代理接口，不能代理实现类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cglib代理&lt;/td&gt;
      &lt;td&gt;代理实现类&lt;/td&gt;
      &lt;td&gt;和动态代理互补&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 27 May 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/05/27/java-proxy/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/05/27/java-proxy/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>浮点精度</title>
        <description>&lt;p&gt;整数、浮点数是开发中经常使用的类型，在Java中，整数常用的有 &lt;code&gt;Integer&lt;/code&gt; 和 &lt;code&gt;Long&lt;/code&gt; ，浮点数有 &lt;code&gt;Float&lt;/code&gt; 和 &lt;code&gt;Double&lt;/code&gt; 。如果使用 &lt;code&gt;Float&lt;/code&gt; 来存储 &lt;code&gt;Integer&lt;/code&gt; 的值可行么？粗略看上去，肯定是没问题的，下面我们看个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Test {
    public static void main(String[] args) {
        int a = 12345678;
        System.out.println(a);
        System.out.println((float) a);
        System.out.println(Float.valueOf(a + &quot;&quot;).intValue());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果会输出什么呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;12345678
1.2345678E7
12345678
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完全正确，不要急，我们将变量a的值调大一些，修改为 123456789，再次执行，输出结果如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;123456789
1.23456792E8
123456792
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;差了一些，有误差了，这个为什么呢？因为浮点数的表示是按照 &lt;code&gt;IEEE 754 &lt;/code&gt;标准的，可以参考&lt;a href=&quot;https://www.zhihu.com/question/21711083&quot;&gt;https://www.zhihu.com/question/21711083&lt;/a&gt; , 字节数和尾数部分见下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;字节数&lt;/th&gt;
      &lt;th&gt;尾数长度&lt;/th&gt;
      &lt;th&gt;精确范围&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Float&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;-2^24 ~ 2^24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Double&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;52&lt;/td&gt;
      &lt;td&gt;-2^53 ~ 2^53&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;因为最高位是1的缘故，加上尾数长度，可以计算出能够精确表示的范围，可以看出 &lt;code&gt;Float&lt;/code&gt; 最大精确数值为 &lt;code&gt;16777216&lt;/code&gt; ,&lt;code&gt;Double&lt;/code&gt; 最大精确数值为 &lt;code&gt;9007199254740992&lt;/code&gt; ，上文中的 &lt;code&gt;12345678&lt;/code&gt; 和 &lt;code&gt;123456789&lt;/code&gt; 刚好在 &lt;code&gt;16777216&lt;/code&gt; 的两侧， 所以出现了上文中的结果。&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;当前时间戳的范围超过了 &lt;code&gt;Float&lt;/code&gt; 的范围，在进行类型转化时已经要注意。 需要精度高的类型，可以选择 &lt;code&gt;BigDecimal&lt;/code&gt; 来完成，如果明确确定对应的数值大小在精确表示范围内，也可以进行转换。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 07 May 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/05/07/float-precision/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/05/07/float-precision/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>剪切板同步</title>
        <description>&lt;p&gt;工作中有两台主机，系统上一台macOS，一台Ubuntu，macOS作为主力机，经常需要将复制文本同步，之前的方案是登陆两个不同的微信进行分享，不过每次都需要打开，比较麻烦。&lt;/p&gt;

&lt;p&gt;有没有什么办法能够解决 macOS 到 Ubuntu 的单向文本复制呢？单向解决了，双向基本也没有问题，鉴于作者没有双向需求，故本文只介绍 macOS 到 Ubuntu 的单项文本同步方案,。目前可行的方案有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方案&lt;/th&gt;
      &lt;th&gt;优缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;IM、飞鸽传书&lt;/td&gt;
      &lt;td&gt;支持双向、操作流程略长&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;剪切板同步软件&lt;/td&gt;
      &lt;td&gt;支持双向，多平台支持不够，很多没有Linux&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SSH&lt;/td&gt;
      &lt;td&gt;支持双向，多平台支持，配置稍微复杂，使用方便&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;本次采用外能的 ssh 进行剪切板同步，考虑到不希望把 macOS 上的剪切板全部同步，只需要同步需要的即可，结合 macOS 上另外一个神器 &lt;code&gt;alfred&lt;/code&gt; 进行。&lt;/p&gt;

&lt;h3 id=&quot;一同步方案&quot;&gt;一、同步方案&lt;/h3&gt;
&lt;p&gt;macOS上操作剪切板非常的简单，&lt;code&gt;pbcopy&lt;/code&gt; 和 &lt;code&gt;pbpaste&lt;/code&gt; 分别对应复制和剪切，操作示例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;➜  ~ echo &quot;Hello Codeboy&quot; | pbcopy 
➜  ~ pbpaste
Hello Codeboy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux上需要安装 &lt;code&gt;xclip&lt;/code&gt; 来完成，操作示例如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;➜  ~ echo &quot;Hello Codeboy&quot; |  xclip -in -selection clipboard
➜  ~ xclip -o                                              
Hello Codeboy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 &lt;code&gt;xclip&lt;/code&gt; 牵扯图形操作，不能直接使用ssh在远程主机上执行命令完成，我们使用文件进行内容传输即可，接收方定时检查文件是否有更新，有更新的话使用 &lt;code&gt;xclip&lt;/code&gt; 同步到剪切板。
同时Ubuntu上需要配置 macOS 中 ssh 公钥，可以免密登陆，具体操作可以查询。&lt;/p&gt;

&lt;h3 id=&quot;二发送方macos&quot;&gt;二、发送方(macOS)&lt;/h3&gt;

&lt;p&gt;我们使用 &lt;code&gt;alfred&lt;/code&gt;中的workflow自定义快捷键执行脚本，操作如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新建空白workflow&lt;/li&gt;
  &lt;li&gt;添加Triggers –&amp;gt; HotKey, 定义喜欢的按键，作者选择(alt+F)，和复制键距离比较近。&lt;/li&gt;
  &lt;li&gt;新建Action –&amp;gt; Run Script, 输入复制脚本即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 将剪切板内容写入文件
pbpaste &amp;gt; /tmp/clip_content
# 发送到目标主机
scp -q /tmp/clip_content user@host:/tmp/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样需要复制的时候，&lt;code&gt;ctrl-C&lt;/code&gt; 后再次按下 &lt;code&gt;alt-F&lt;/code&gt; 即可发送。&lt;/p&gt;

&lt;h3 id=&quot;三接收方ubuntu&quot;&gt;三、接收方(Ubuntu)&lt;/h3&gt;

&lt;p&gt;接收方监听 &lt;code&gt;/tmp/clip_content&lt;/code&gt; 文件内容变化即可，脚本如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
last_content=&quot;&quot;
while true
do
 content=`cat /tmp/clip_content`
 if [ &quot;$content&quot; != &quot;$last_content&quot; ]
    then
      echo $content;
      xclip -in -selection clipboard &amp;lt; /tmp/clip_content
      last_content=&quot;$content&quot;
 fi
 sleep 1
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每秒钟检测该文件内容是否改变，改变的话复制到剪切板中，实时性还是很高的。打开终端，执行起来即可。&lt;/p&gt;

&lt;h3 id=&quot;四使用&quot;&gt;四、使用&lt;/h3&gt;

&lt;p&gt;macOS上遇到需要复制的文本，&lt;code&gt;ctrl-C --&amp;gt; alt-F&lt;/code&gt; 后, 切换到Ubuntu，直接粘贴即可。有更快捷的方式欢迎留言。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 17 Apr 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/04/17/clipboard-sync/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/04/17/clipboard-sync/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>零点时间</title>
        <description>&lt;p&gt;在一些按天计算的场景中，需要获取当天凌晨零点的时间，有什么快捷高效的做法呢？下面针对Java中的几种计算方式进行比较：&lt;/p&gt;

&lt;h4 id=&quot;simpledateformat&quot;&gt;SimpleDateFormat&lt;/h4&gt;

&lt;p&gt;获取当前时间对应的年月日，反向计算即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static long getTimeWay1() {
    try {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.CHINA);
        return sdf.parse(sdf.format(System.currentTimeMillis())).getTime();
    } catch (ParseException e) {
        e.printStackTrace();
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;calendar&quot;&gt;Calendar&lt;/h4&gt;

&lt;p&gt;使用 &lt;code&gt;java.util.Calendar&lt;/code&gt; 类，可以便捷去除时分秒以及毫秒的数值，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static long getTimeWay2() {
    Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
    //注意，这里不是Calendar.HOUR, 需要按照24小时的Calendar.HOUR_OF_DAY进行
    calendar.set(Calendar.HOUR_OF_DAY, 0);
    calendar.set(Calendar.MINUTE, 0);
    calendar.set(Calendar.SECOND, 0);
    calendar.set(Calendar.MILLISECOND, 0);
    return calendar.getTimeInMillis();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;除法&quot;&gt;除法&lt;/h4&gt;

&lt;p&gt;借鉴 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 的方式，本次直接使用除法操作即可，需要注意一点的是时区问题，东八区相对于零时区增加了八个小时，处理中需要处理一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static long getTimeWay3() {
    long ONE_DAY = 24 * 3600 * 1000;
    long now = System.currentTimeMillis();
    long offset = TimeZone.getDefault().getRawOffset();
    return (now + offset) / ONE_DAY * ONE_DAY - offset;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方式&lt;/th&gt;
      &lt;th&gt;性能&lt;/th&gt;
      &lt;th&gt;使用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SimpleDateFormat&lt;/td&gt;
      &lt;td&gt;一般&lt;/td&gt;
      &lt;td&gt;一般&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Calendar&lt;/td&gt;
      &lt;td&gt;高&lt;/td&gt;
      &lt;td&gt;方便&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;除法&lt;/td&gt;
      &lt;td&gt;最高&lt;/td&gt;
      &lt;td&gt;时区问题需要注意&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对比下来, 推荐使用第二种&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 13 Apr 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/04/13/java-today-zero-hour/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/04/13/java-today-zero-hour/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>Zip几点小知识</title>
        <description>&lt;h3 id=&quot;问题来源&quot;&gt;问题来源&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;zip怎么加速解压速度？&lt;/li&gt;
  &lt;li&gt;相同文件分别压缩为 &lt;code&gt;a.zip&lt;/code&gt;  和 &lt;code&gt;b.zip&lt;/code&gt; 后，计算出的md5一样么？原因是？&lt;/li&gt;
  &lt;li&gt;zip文件的时间是怎么计算的？ (二进制上是怎么计算的)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;zip怎么加速解压速度&quot;&gt;zip怎么加速解压速度&lt;/h3&gt;

&lt;p&gt;为什么会有这个问题，源于近来项目中有一些cache包下发到手机中，需要解压，但是在一些中低端手机上，解压速度非常的慢，在一些算法求解中，常见的方式是使用空间换时间，zip中可行么？答案是可行的，看一下zip的几个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;-0   store only 不压缩
-1   compress faster 最快压缩，压缩率最差。
-9   compress better 最大压缩，压缩率最佳。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;0-9之间代表不同的压缩率，可以使用 &lt;code&gt;-0&lt;/code&gt; 参数进行无损压缩，换句话说，即简单的将文件进行拼接即可。 对一个6.4M的js、css资源按照0、1、9压缩后，大小分别是5.7M、2.4M、2.1M，在手机解压速度测试中时间大幅度减少。&lt;/p&gt;

&lt;h3 id=&quot;相同文件压缩后的zip的md5值是否相同&quot;&gt;相同文件压缩后的zip的md5值是否相同&lt;/h3&gt;

&lt;p&gt;一直有个疑问，对同一个文件进行压缩，一次压缩结果为 &lt;code&gt;1.zip&lt;/code&gt;, 另外一次是 &lt;code&gt;2.zip&lt;/code&gt;, 计算两个文件的md5，会是一样的么？ 先说一下结果，可能一样，也可能不一样，首先文件名对md5的结果没有影响，然后前后手动压缩一个文本文件，查看两个文件的二进制，发现只有一个字节不同，第一感觉大家应该都会想到是时间问题，确实是时间的改变造成了2个文件的差异，zip结构中有个 &lt;code&gt;Extra Filed&lt;/code&gt;，里面记录了文件上次修改和上次访问时间，当对文件进行第一次压缩时，文件的访问时间可能会被修改，因为该时间计算单位是秒，所以在脚本执行的情况下，会出现以下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;➜  zip ./a.sh 
adding: hello.txt (stored 0%)
MD5 (h1.zip) = a277a7f05ca3cba3eb119424068aad95
adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = 5b69e56cc533d19c14c1aa234bd7d6e3
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = 5b69e56cc533d19c14c1aa234bd7d6e3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，md5 会随着时间的偏移改变。在计算文件差异的时候，经常不需要关系此种信息，我们可以使用 &lt;code&gt;-X&lt;/code&gt; 参数去除extra属性。&lt;/p&gt;

&lt;h3 id=&quot;zip文件的时间计算&quot;&gt;zip文件的时间计算&lt;/h3&gt;

&lt;p&gt;研究了下zip文件的格式，在 &lt;strong&gt;Local file header&lt;/strong&gt; 中有一个对应的文件修改日期和修改时间字段，分别为2个字节，如下(小端模式下，读取时需要倒序):&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Offset&lt;/th&gt;
      &lt;th&gt;字符&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;50 4b 03 04&lt;/td&gt;
      &lt;td&gt;头部魔数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0a 00&lt;/td&gt;
      &lt;td&gt;版本 (10)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;00 00&lt;/td&gt;
      &lt;td&gt;标记, 加密与否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;00 00&lt;/td&gt;
      &lt;td&gt;压缩算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;89 aa&lt;/td&gt;
      &lt;td&gt;最近修改时间 (这个)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;71 4e&lt;/td&gt;
      &lt;td&gt;最近修改日期 (这个)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;2d 3b 08 af&lt;/td&gt;
      &lt;td&gt;crc-32&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;0c 00 00 00&lt;/td&gt;
      &lt;td&gt;压缩大小，12B (12)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;0c 00 00 00&lt;/td&gt;
      &lt;td&gt;未压缩大小，12B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;09 00&lt;/td&gt;
      &lt;td&gt;文件名字长度 (9)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;1c 00&lt;/td&gt;
      &lt;td&gt;扩展区域长度 (28)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;文件内容&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;最近修改时间&quot;&gt;最近修改时间&lt;/h4&gt;

&lt;p&gt;aa89 = 10101 010100 01001 =  21:20:09&lt;/p&gt;

&lt;h4 id=&quot;最近修改日期&quot;&gt;最近修改日期&lt;/h4&gt;

&lt;p&gt;4e71 = 0100111 0011 10001 = 39-03-17(年+1980) = 2019-03-17&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://adoyle.me/blog/why-zip-file-checksum-changed.html&quot;&gt;http://adoyle.me/blog/why-zip-file-checksum-changed.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://opensource.apple.com/source/zip/zip-6/unzip/unzip/proginfo/extra.fld&quot;&gt;https://opensource.apple.com/source/zip/zip-6/unzip/unzip/proginfo/extra.fld&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 20 Mar 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/03/20/zip-tricks/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/03/20/zip-tricks/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>Andorid AsyncTask解析</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;AsyncTask 在Android开发中是一个经常用到的类，允许用户在工作线程上完成后台计算等任务，之后将结果同步UI线程，比起 Thread 和  Handler 模型使用起来方便一些。&lt;/p&gt;

&lt;p&gt;AsyncTask 使用起来如此方便了，那么有什么需要注意的问题么？看一段AsyncTask官网的介绍文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution.

If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，从 Android1.6 到  Android2.2 之间，AsyncTask是并行执行的，从HONEYCOMB(2.3)开始，为了避免并行执行造成的通用应用错误，任务的执行方式修改为串行。&lt;/p&gt;

&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;

&lt;p&gt;我们从最新的Android 8.0中分析一下AsyncTask：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * An {@link Executor} that can be used to execute tasks in parallel.
 */
public static final Executor THREAD_POOL_EXECUTOR;

static {
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
            sPoolWorkQueue, sThreadFactory);
    threadPoolExecutor.allowCoreThreadTimeOut(true);
    THREAD_POOL_EXECUTOR = threadPoolExecutor;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AsyncTask中定义了一个线程池，在我们执行execute(params)的时候的操作如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@MainThread
public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; execute(Params... params) {
    return executeOnExecutor(sDefaultExecutor, params);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@MainThread
public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; executeOnExecutor(Executor exec,
        Params... params) {
    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task is already running.&quot;);
            case FINISHED:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task has already been executed &quot;
                        + &quot;(a task can be executed only once)&quot;);
        }
    }

    mStatus = Status.RUNNING;

	//之前前的准备工作
    onPreExecute();

    mWorker.mParams = params;
    //真正添加任务并执行
    exec.execute(mFuture);

    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中Executor传递了一个sDefaultExecutor，sDefaultExecutor的定义如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;
public static final Executor SERIAL_EXECUTOR = new SerialExecutor();
//串行执行器
private static class SerialExecutor implements Executor {
    final ArrayDeque&amp;lt;Runnable&amp;gt; mTasks = new ArrayDeque&amp;lt;Runnable&amp;gt;();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        //将任务加入队列中
        mTasks.offer(new Runnable() {
            public void run() {
                try {
                    r.run();
                } finally {
                    scheduleNext();
                }
            }
        });
        //如果首次添加，执行任务
        if (mActive == null) {
            scheduleNext();
        }
    }

    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里应该比较明确了，默认的executor使用的 SerialExecutor，而 SerialExecutor 的 execute 中的逻辑也很简单，直接添加队列，如果第一次添加的话，从队列中取出一个任务执行，进而达到了串行执行的结果。&lt;/p&gt;

&lt;p&gt;到此，AsyncTask 为什么串行执行已经分析完毕。&lt;/p&gt;

&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;

&lt;p&gt;当前主流的应用，如手机淘宝、支付宝等的最低支持版本均已经是4.0，所以在开发中，系统的默认的AsyncTask的执行时串行的，我们可以进行修改。上面分析中也有提到，在AsyncTask执行execute方法的时候，使用了默认的Executor，我们可以使用AsyncTask中提供的另外一个方法 executeOnExecutor 指定线程池来执行，需要注意的一点是AsyncTask提供了线程池的 AsyncTask.THREAD_POOL_EXECUTOR ，我们可以使用这个线程池，但是这个线程池的参数中的队列长度是128，线程池拒绝策略采用的 AbortPolicy  ，任务超出线程池可承受范围(MAXIMUM_POOL_SIZE + POOL_SIZE)时，将会发生异常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE_SECONDS = 30;

//线程池队列
private static final BlockingQueue&amp;lt;Runnable&amp;gt; sPoolWorkQueue =
        new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(128);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们使用这个线程池，添加了比较多的耗时任务，将会crash，测试代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test;

import android.os.AsyncTask;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;

import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class MainActivity extends AppCompatActivity {
    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));
    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
    private static final int KEEP_ALIVE_SECONDS = 30;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);


        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
                new LinkedBlockingDeque&amp;lt;&amp;gt;(128));
        for (int i = 0; i &amp;lt; 200; i++) {
            new AsyncTask&amp;lt;Integer, Void, Void&amp;gt;() {
                @Override
                protected void onPostExecute(Void aVoid) {
                    super.onPostExecute(aVoid);

                }

                @Override
                protected Void doInBackground(Integer... params) {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if (params != null || params.length &amp;gt; 0) {
                        Log.e(MainActivity.this.getClass().getSimpleName(), &quot;&quot; + params[0]);
                    }
                    return null;
                }
            }.executeOnExecutor(threadPoolExecutor, i);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
java.lang.RuntimeException: Unable to start activity ComponentInfo{me.codeboy.test/me.codeboy.test.MainActivity}: java.util.concurrent.RejectedExecutionException: Task android.os.AsyncTask$3@a1014c4 rejected from java.util.concurrent.ThreadPoolExecutor@2c4bfad[Running, pool size = 9, active threads = 9, queued tasks = 128, completed tasks = 0]
   at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2817)
   at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2892)
   at android.app.ActivityThread.-wrap11(Unknown Source:0)
   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1593)
   at android.os.Handler.dispatchMessage(Handler.java:105)
   at android.os.Looper.loop(Looper.java:164)
   at android.app.ActivityThread.main(ActivityThread.java:6541)
   at java.lang.reflect.Method.invoke(Native Method)
   at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)
   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767)
Caused by: java.util.concurrent.RejectedExecutionException: Task android.os.AsyncTask$3@a1014c4 rejected from java.util.concurrent.ThreadPoolExecutor@2c4bfad[Running, pool size = 9, active threads = 9, queued tasks = 128, completed tasks = 0]
   at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2078)
   at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:843)
   at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1389)
   at android.os.AsyncTask.executeOnExecutor(AsyncTask.java:651)
   at me.codeboy.test.MainActivity.onCreate(MainActivity.java:50)
   at android.app.Activity.performCreate(Activity.java:6975)
   at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1213)
   at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2770)
   at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2892) 
   at android.app.ActivityThread.-wrap11(Unknown Source:0) 
   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1593) 
   at android.os.Handler.dispatchMessage(Handler.java:105) 
   at android.os.Looper.loop(Looper.java:164) 
   at android.app.ActivityThread.main(ActivityThread.java:6541) 
   at java.lang.reflect.Method.invoke(Native Method) 
   at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240) 
   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;避免的方法是可以将队列大小加大或者不限制大小，在不限制大小的时候，如果MAXIMUM_POOL_SIZE和CORE_POOL_SIZE不同，那么MAXIMUM_POOL_SIZE将失去意义。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 04 Aug 2018 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2018/08/04/android-async-task/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2018/08/04/android-async-task/</guid>
        
        <category>android</category>
        
        
      </item>
    
  </channel>
</rss>
