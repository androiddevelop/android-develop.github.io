<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小胖轩</title>
    <description>编码生涯的点点滴滴</description>
    <link>https://https://www.codeboy.me/</link>
    <atom:link href="https://https://www.codeboy.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 13 Apr 2019 05:38:30 +0800</pubDate>
    <lastBuildDate>Sat, 13 Apr 2019 05:38:30 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Zip几点小知识</title>
        <description>&lt;h2 id=&quot;问题来源&quot;&gt;问题来源&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;zip怎么加速解压速度？&lt;/li&gt;
  &lt;li&gt;相同文件分别压缩为 &lt;code&gt;a.zip&lt;/code&gt;  和 &lt;code&gt;b.zip&lt;/code&gt; 后，计算出的md5一样么？原因是？&lt;/li&gt;
  &lt;li&gt;zip文件的时间是怎么计算的？ (二进制上是怎么计算的)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-zip怎么加速解压速度&quot;&gt;1. zip怎么加速解压速度&lt;/h2&gt;

&lt;p&gt;为什么会有这个问题，源于近来项目中有一些cache包下发到手机中，需要解压，但是在一些中低端手机上，解压速度非常的慢，在一些算法求解中，常见的方式是使用空间换时间，zip中可行么？答案是可行的，看一下zip的几个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;-0   store only 不压缩
-1   compress faster 最快压缩，压缩率最差。
-9   compress better 最大压缩，压缩率最佳。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;0-9之间代表不同的压缩率，可以使用 &lt;code&gt;-0&lt;/code&gt; 参数进行无损压缩，换句话说，即简单的将文件进行拼接即可。 对一个6.4M的js、css资源按照0、1、9压缩后，大小分别是5.7M、2.4M、2.1M，在手机解压速度测试中时间大幅度减少。&lt;/p&gt;

&lt;h2 id=&quot;2-相同文件压缩后的zip的md5值是否相同&quot;&gt;2. 相同文件压缩后的zip的md5值是否相同&lt;/h2&gt;

&lt;p&gt;一直有个疑问，对同一个文件进行压缩，一次压缩结果为 &lt;code&gt;1.zip&lt;/code&gt;, 另外一次是 &lt;code&gt;2.zip&lt;/code&gt;, 计算两个文件的md5，会是一样的么？ 先说一下结果，可能一样，也可能不一样，首先文件名对md5的结果没有影响，然后前后手动压缩一个文本文件，查看两个文件的二进制，发现只有一个字节不同，第一感觉大家应该都会想到是时间问题，确实是时间的改变造成了2个文件的差异，zip结构中有个 &lt;code&gt;Extra Filed&lt;/code&gt;，里面记录了文件上次修改和上次访问时间，当对文件进行第一次压缩时，文件的访问时间可能会被修改，因为该时间计算单位是秒，所以在脚本执行的情况下，会出现以下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;➜  zip ./a.sh 
adding: hello.txt (stored 0%)
MD5 (h1.zip) = a277a7f05ca3cba3eb119424068aad95
adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = 5b69e56cc533d19c14c1aa234bd7d6e3
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = 5b69e56cc533d19c14c1aa234bd7d6e3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，md5 会随着时间的偏移改变。在计算文件差异的时候，经常不需要关系此种信息，我们可以使用 &lt;code&gt;-X&lt;/code&gt; 参数去除extra属性。&lt;/p&gt;

&lt;h2 id=&quot;3-zip文件的时间计算&quot;&gt;3. zip文件的时间计算&lt;/h2&gt;

&lt;p&gt;研究了下zip文件的格式，在 &lt;strong&gt;Local file header&lt;/strong&gt; 中有一个对应的文件修改日期和修改时间字段，分别为2个字节，如下(小端模式下，读取时需要倒序):&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Offset&lt;/th&gt;
      &lt;th&gt;字符&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;50 4b 03 04&lt;/td&gt;
      &lt;td&gt;头部魔数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0a 00&lt;/td&gt;
      &lt;td&gt;版本 (10)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;00 00&lt;/td&gt;
      &lt;td&gt;标记, 加密与否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;00 00&lt;/td&gt;
      &lt;td&gt;压缩算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;89 aa&lt;/td&gt;
      &lt;td&gt;最近修改时间 (这个)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;71 4e&lt;/td&gt;
      &lt;td&gt;最近修改日期 (这个)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;2d 3b 08 af&lt;/td&gt;
      &lt;td&gt;crc-32&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;0c 00 00 00&lt;/td&gt;
      &lt;td&gt;压缩大小，12B (12)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;0c 00 00 00&lt;/td&gt;
      &lt;td&gt;未压缩大小，12B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;09 00&lt;/td&gt;
      &lt;td&gt;文件名字长度 (9)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;1c 00&lt;/td&gt;
      &lt;td&gt;扩展区域长度 (28)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;文件内容&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;最近修改时间&quot;&gt;最近修改时间&lt;/h4&gt;

&lt;p&gt;aa89 = 10101 010100 01001 =  21:20:09&lt;/p&gt;

&lt;h4 id=&quot;最近修改日期&quot;&gt;最近修改日期&lt;/h4&gt;

&lt;p&gt;4e71 = 0100111 0011 10001 = 39-03-17(年+1980) = 2019-03-17&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://adoyle.me/blog/why-zip-file-checksum-changed.html&quot;&gt;http://adoyle.me/blog/why-zip-file-checksum-changed.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://opensource.apple.com/source/zip/zip-6/unzip/unzip/proginfo/extra.fld&quot;&gt;https://opensource.apple.com/source/zip/zip-6/unzip/unzip/proginfo/extra.fld&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 20 Mar 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/03/20/zip-tricks/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/03/20/zip-tricks/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>Andorid AsyncTask解析</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;AsyncTask 在Android开发中是一个经常用到的类，允许用户在工作线程上完成后台计算等任务，之后将结果同步UI线程，比起 Thread 和  Handler 模型使用起来方便一些。&lt;/p&gt;

&lt;p&gt;AsyncTask 使用起来如此方便了，那么有什么需要注意的问题么？看一段AsyncTask官网的介绍文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution.

If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，从 Android1.6 到  Android2.2 之间，AsyncTask是并行执行的，从HONEYCOMB(2.3)开始，为了避免并行执行造成的通用应用错误，任务的执行方式修改为串行。&lt;/p&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;

&lt;p&gt;我们从最新的Android 8.0中分析一下AsyncTask：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * An {@link Executor} that can be used to execute tasks in parallel.
 */
public static final Executor THREAD_POOL_EXECUTOR;

static {
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
            sPoolWorkQueue, sThreadFactory);
    threadPoolExecutor.allowCoreThreadTimeOut(true);
    THREAD_POOL_EXECUTOR = threadPoolExecutor;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AsyncTask中定义了一个线程池，在我们执行execute(params)的时候的操作如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@MainThread
public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; execute(Params... params) {
    return executeOnExecutor(sDefaultExecutor, params);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@MainThread
public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; executeOnExecutor(Executor exec,
        Params... params) {
    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task is already running.&quot;);
            case FINISHED:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task has already been executed &quot;
                        + &quot;(a task can be executed only once)&quot;);
        }
    }

    mStatus = Status.RUNNING;

	//之前前的准备工作
    onPreExecute();

    mWorker.mParams = params;
    //真正添加任务并执行
    exec.execute(mFuture);

    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中Executor传递了一个sDefaultExecutor，sDefaultExecutor的定义如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;
public static final Executor SERIAL_EXECUTOR = new SerialExecutor();
//串行执行器
private static class SerialExecutor implements Executor {
    final ArrayDeque&amp;lt;Runnable&amp;gt; mTasks = new ArrayDeque&amp;lt;Runnable&amp;gt;();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        //将任务加入队列中
        mTasks.offer(new Runnable() {
            public void run() {
                try {
                    r.run();
                } finally {
                    scheduleNext();
                }
            }
        });
        //如果首次添加，执行任务
        if (mActive == null) {
            scheduleNext();
        }
    }

    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里应该比较明确了，默认的executor使用的 SerialExecutor，而 SerialExecutor 的 execute 中的逻辑也很简单，直接添加队列，如果第一次添加的话，从队列中取出一个任务执行，进而达到了串行执行的结果。&lt;/p&gt;

&lt;p&gt;到此，AsyncTask 为什么串行执行已经分析完毕。&lt;/p&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;

&lt;p&gt;当前主流的应用，如手机淘宝、支付宝等的最低支持版本均已经是4.0，所以在开发中，系统的默认的AsyncTask的执行时串行的，我们可以进行修改。上面分析中也有提到，在AsyncTask执行execute方法的时候，使用了默认的Executor，我们可以使用AsyncTask中提供的另外一个方法 executeOnExecutor 指定线程池来执行，需要注意的一点是AsyncTask提供了线程池的 AsyncTask.THREAD_POOL_EXECUTOR ，我们可以使用这个线程池，但是这个线程池的参数中的队列长度是128，线程池拒绝策略采用的 AbortPolicy  ，任务超出线程池可承受范围(MAXIMUM_POOL_SIZE + POOL_SIZE)时，将会发生异常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE_SECONDS = 30;

//线程池队列
private static final BlockingQueue&amp;lt;Runnable&amp;gt; sPoolWorkQueue =
        new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(128);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们使用这个线程池，添加了比较多的耗时任务，将会crash，测试代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test;

import android.os.AsyncTask;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;

import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class MainActivity extends AppCompatActivity {
    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));
    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
    private static final int KEEP_ALIVE_SECONDS = 30;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);


        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
                new LinkedBlockingDeque&amp;lt;&amp;gt;(128));
        for (int i = 0; i &amp;lt; 200; i++) {
            new AsyncTask&amp;lt;Integer, Void, Void&amp;gt;() {
                @Override
                protected void onPostExecute(Void aVoid) {
                    super.onPostExecute(aVoid);

                }

                @Override
                protected Void doInBackground(Integer... params) {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if (params != null || params.length &amp;gt; 0) {
                        Log.e(MainActivity.this.getClass().getSimpleName(), &quot;&quot; + params[0]);
                    }
                    return null;
                }
            }.executeOnExecutor(threadPoolExecutor, i);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
java.lang.RuntimeException: Unable to start activity ComponentInfo{me.codeboy.test/me.codeboy.test.MainActivity}: java.util.concurrent.RejectedExecutionException: Task android.os.AsyncTask$3@a1014c4 rejected from java.util.concurrent.ThreadPoolExecutor@2c4bfad[Running, pool size = 9, active threads = 9, queued tasks = 128, completed tasks = 0]
   at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2817)
   at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2892)
   at android.app.ActivityThread.-wrap11(Unknown Source:0)
   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1593)
   at android.os.Handler.dispatchMessage(Handler.java:105)
   at android.os.Looper.loop(Looper.java:164)
   at android.app.ActivityThread.main(ActivityThread.java:6541)
   at java.lang.reflect.Method.invoke(Native Method)
   at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)
   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767)
Caused by: java.util.concurrent.RejectedExecutionException: Task android.os.AsyncTask$3@a1014c4 rejected from java.util.concurrent.ThreadPoolExecutor@2c4bfad[Running, pool size = 9, active threads = 9, queued tasks = 128, completed tasks = 0]
   at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2078)
   at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:843)
   at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1389)
   at android.os.AsyncTask.executeOnExecutor(AsyncTask.java:651)
   at me.codeboy.test.MainActivity.onCreate(MainActivity.java:50)
   at android.app.Activity.performCreate(Activity.java:6975)
   at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1213)
   at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2770)
   at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2892) 
   at android.app.ActivityThread.-wrap11(Unknown Source:0) 
   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1593) 
   at android.os.Handler.dispatchMessage(Handler.java:105) 
   at android.os.Looper.loop(Looper.java:164) 
   at android.app.ActivityThread.main(ActivityThread.java:6541) 
   at java.lang.reflect.Method.invoke(Native Method) 
   at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240) 
   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;避免的方法是可以将队列大小加大或者不限制大小，在不限制大小的时候，如果MAXIMUM_POOL_SIZE和CORE_POOL_SIZE不同，那么MAXIMUM_POOL_SIZE将失去意义。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 04 Aug 2018 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2018/08/04/android-async-task/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2018/08/04/android-async-task/</guid>
        
        <category>android</category>
        
        
      </item>
    
      <item>
        <title>Linux命令之ln</title>
        <description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;这几天一直想更换下osx下用户家目录的名字，为什么要更换呢? 因为之前托同学帮忙买来mac的时候已经创建了用户，当时也懒，也没用过osx，所以就一直到现在了。公司里的电脑是另外一台Macbook Pro，每次有一些牵扯到绝对路径的脚本等内容使用时，都需要改动配置等，于是乎决定对自己这台mac进行家目录重命名，大概的操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;系统设置 --&amp;gt;  用户和组 --&amp;gt; 解锁左下角小锁 --&amp;gt; 右击列表中用户 --&amp;gt; 高级选项 --&amp;gt; 修改家目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于家目录的修改这里不做详细介绍， 网上有很多教程，不过请做好数据备份。路径修改后，希望能通过访问新的路径访问到原先家目录对应的文件，毕竟各种软件的配置等信息都还在，这时候就需要用上Linux中ln命令。&lt;/p&gt;

&lt;h2 id=&quot;ln命令简介&quot;&gt;ln命令简介&lt;/h2&gt;
&lt;p&gt;ln是link的缩写，可以用来创建软连接和硬连接，使用和特点如下：&lt;/p&gt;

&lt;h4 id=&quot;软链接&quot;&gt;软链接：&lt;/h4&gt;

&lt;p&gt;使用操作:	&lt;code&gt;ln -s source target&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;软链接以路径的形式存在, 类似于Windows操作系统中的快捷方式&lt;/li&gt;
  &lt;li&gt;软链接可以跨文件系统, 硬链接不可以&lt;/li&gt;
  &lt;li&gt;软链接可以对一个不存在的文件名进行链接&lt;/li&gt;
  &lt;li&gt;软链接可以对目录进行链接&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;硬链接&quot;&gt;硬链接：&lt;/h4&gt;

&lt;p&gt;使用操作:	&lt;code&gt;ln source target&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;硬链接以文件副本的形式存在, 但不占用实际空间。&lt;/li&gt;
  &lt;li&gt;不允许给目录创建硬链接&lt;/li&gt;
  &lt;li&gt;硬链接只有在同一个文件系统中才能创建&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;更多其他参数的使用，可以&lt;code&gt;man ln&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;

&lt;p&gt;既然家目录改变了，可以将新的家目录连接的旧的家目录即可解决问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -s old_home new_home
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;两台mac的家目录统一了，很多文件、项目等的配置不用做任何修改了，哈哈。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 07 Jan 2018 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2018/01/07/linux-command-ln/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2018/01/07/linux-command-ln/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>Shell下解析Json之jq</title>
        <description>&lt;p&gt;Json是一种轻量级的数据交换格式，简洁和清晰的层次结构使得Json成为理想的数据交换语言，易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。&lt;/p&gt;

&lt;p&gt;软件开发中经常会将对象序列化为Json，或者将对应的Json串反序列化为对象，在Android开发、服务端开发中都有很多库，如fastjson、gson等, 今天来看一下shell的json解析工具jq。&lt;/p&gt;

&lt;h3 id=&quot;一安装&quot;&gt;一、安装&lt;/h3&gt;
&lt;p&gt;jq的官网地址&lt;a href=&quot;https://github.com/stedolan/jq&quot;&gt;https://github.com/stedolan/jq&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-mac&quot;&gt;1. mac&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;brew install jq
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;mac下安装时可能会提示更新xcode，如提示请更新。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;2-linux&quot;&gt;2. linux&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;apt-get install jq
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;ubuntu以及衍生版本可以直接仓库安装， 其他的发行版也可以尝试仓库或者源码编译&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;二基本用法&quot;&gt;二、基本用法&lt;/h3&gt;
&lt;p&gt;解析json最常用的要数取值和获取数组长度操作了，给出一段常见的json，结合场景介绍下简单的使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;data&quot;: [
    &quot;张三&quot;,
    &quot;李四&quot;
  ],
  &quot;code&quot;: &quot;SUCCESS&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假定content代表上面的字符串。&lt;/p&gt;

&lt;p&gt;jq获取字段时的格式为&lt;code&gt;.字段名&lt;/code&gt;，例如获取code值时，操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $content | grep '.code'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取data的长度的格式如下&lt;code&gt;'length'&lt;/code&gt;,直接使用不加.的length即可，操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $content | jq '.data|length'
echo $content | jq '.data' | jq 'length'
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;更加详细的文档可以参见 &lt;a href=&quot;https://stedolan.github.io/jq/manual/&quot;&gt;https://stedolan.github.io/jq/manual&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;三场景使用&quot;&gt;三、场景使用&lt;/h3&gt;
&lt;p&gt;获取&lt;a href=&quot;https://www.codeboy.me&quot;&gt;小胖轩&lt;/a&gt;博客中的文章列表，由于之前小胖轩网站中加入了博客搜索功能，有一个对应的文章索引&lt;a href=&quot;https://www.codeboy.me/search/cb-search.json&quot;&gt;https://www.codeboy.me/search/cb-search.json&lt;/a&gt;，我们需要做的操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 下载cb-search.json文件
2. 解析json文件，遍历文章列表
3. 输出文章标题列表
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用jq进行解析即可:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 获取codeboy.me中所有文章的标题

json=`curl -s &quot;https://www.codeboy.me/search/cb-search.json&quot;`;

#获取文章列表
list=`echo $json | jq '.data'`;

#获取文章长度
length=`echo $json | jq'.data|length' `;

# 解析data字段后，开始遍历每一项，取出标题
for index in `seq 0 $length`
do
	echo $list | jq &quot;.[$index].title&quot;;
done

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;四小结&quot;&gt;四、小结&lt;/h3&gt;
&lt;p&gt;shell下写脚本非常的方便快捷，有了jq，可以完成更丰富的操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 27 Nov 2017 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2017/11/27/command-jq/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2017/11/27/command-jq/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>正则表达式之非获取匹配</title>
        <description>&lt;p&gt;正则表达式是平时开发中经常用到的技巧，大部分时候我们需要的是判断字符串有没有含有固定的模式串，但是某些场景下需要使用非获取匹配，下面根据一种常见的情景:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;匹配所有含有 &lt;code&gt;app://page.cb/myPage?id=xxxx&lt;/code&gt;的地址，但是排除参数中携带&lt;code&gt;downgrade=true&lt;/code&gt;的地址。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;具体用几个例子说明一下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;原始地址: app://page.cb/myPage
匹配结果: no， id不存在

原始地址: app://page.cb/myPage?id=123456
匹配结果: yes

原始地址: app://page.cb/myPage?param=123456
匹配结果: no, id不存在

原始地址: app://page.cb/myPage?id=123456&amp;amp;downgrade=true
匹配结果: no, downgrade为true

原始地址: app://page.cb/myPage?id=123456&amp;amp;downgrade=false
匹配结果: yes

原始地址: app://page.cb/myPage?downgrade=false&amp;amp;id=123456
匹配结果: yes

原始地址: app://page.cb/myPage?downgrade=true&amp;amp;id=123456
匹配结果: no, downgrade为true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配所有不含&lt;code&gt;downgrade=true&lt;/code&gt;的&lt;code&gt;app://page.cb/myPage?id=xxxx&lt;/code&gt;地址，这里可以使用正则表达式的非获取匹配，下面介绍非获取匹配的两种:&lt;/p&gt;

&lt;h4 id=&quot;pattern&quot;&gt;(?!pattern)&lt;/h4&gt;

&lt;p&gt;非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。&lt;/p&gt;

&lt;h4 id=&quot;pattern-1&quot;&gt;(?&amp;lt;!pattern)&lt;/h4&gt;

&lt;p&gt;非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&amp;lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。&lt;/p&gt;

&lt;p&gt;根据非获取匹配的写法， 我们采用了正向否定查询，正则表达式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app:\/\/page.cb\/myPage\?(((?!downgrade=true).)*id=\d+((?!downgrade=true).)*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对其中的反向预查部分进行分割如下：&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;background-color:#B5EF79; font-weight: 700;&quot;&gt;app:\/\/page.cb\/myPage&lt;/span&gt;&lt;span style=&quot;background-color:#FDBE73; font-weight: 700;&quot;&gt;\?&lt;/span&gt;(&lt;span style=&quot;background-color:#77C5FD; font-weight: 700;&quot;&gt;((?!downgrade=true).)*&lt;/span&gt;&lt;span style=&quot;background-color:#B5EF79&quot;&gt;id=\d+&lt;/span&gt;&lt;span style=&quot;background-color:#77C5FD; font-weight: 700;&quot;&gt;((?!downgrade=true).)*&lt;/span&gt;)&lt;/p&gt;

&lt;p&gt;可以在&lt;a href=&quot;https://regex101.com/&quot;&gt;https://regex101.com&lt;/a&gt; 中尝试匹配。&lt;/p&gt;

&lt;p&gt;分析以上正则表达式，即 &lt;code&gt;id=\d+&lt;/code&gt; 的前后都不能含有 &lt;code&gt;downgrade=true&lt;/code&gt; ，其中 &lt;code&gt;((?!downgrade=true).)*&lt;/code&gt; 从里到外看，&lt;code&gt;(?!downgrade=true)&lt;/code&gt; 代表不含该字符串，然后.用于匹配id参数前后的其他参数,此处的.不能防止在 &lt;code&gt;(?!downgrade=true)&lt;/code&gt; 的前面，会造成如果第一个参数是 &lt;code&gt;downgrade=true&lt;/code&gt; 时被遗漏掉。&lt;/p&gt;

&lt;p&gt;如果需要url中参数部分，其中$1即为参数部分。&lt;/p&gt;

&lt;p&gt;测试case集合：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app://page.cb/myPage
app://page.cb/myPage?id=123456
app://page.cb/myPage?param=123456
app://page.cb/myPage?id=123456&amp;amp;downgrade=true
app://page.cb/myPage?id=123456&amp;amp;downgrade=false
app://page.cb/myPage?downgrade=false&amp;amp;id=123456
app://page.cb/myPage?downgrade=true&amp;amp;id=123456
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于各种语言对正则表达式支持程度不同，例如非获取匹配中的反向否定预查在javascript中不支持，但是在php,python,java中是支持的，正向否定预查在javascript,php,python,java中都支持，所以使用前一定要注意，同事需要考虑正则表达式的性能问题。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 01 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2017/10/01/regex-trick/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2017/10/01/regex-trick/</guid>
        
        <category>trick</category>
        
        
      </item>
    
      <item>
        <title>Chrome内容保存插件 - Just One File</title>
        <description>&lt;p&gt;随着互联网的发展，当前我们可以方便的在网站中找到各种各样的资源，尽管现在网络已经无处不在，但是有些时候我们仍然需要保存一些信息到本地，于是开发一个Chrome插件的想法产生了。&lt;/p&gt;

&lt;h2 id=&quot;初衷&quot;&gt;初衷&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;所见即所存&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;目前很多网站都是动态产生的，而浏览器保存的是网页源码， 看到的和保存的内容是可能不一样的，特别是在没有网络的情况下打开。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;去除无用信息&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;很多网站页面中充满了广告等不相关的元素，这些元素影响了信息的查看，去除了后将提升阅读体验。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;针对第一个问题，可以直接保存浏览器当前的dom树，这样就可以达到所见即所存了。&lt;/li&gt;
  &lt;li&gt;针对第二个问题，目前像chrome等浏览器已经可以非常方便的操作dom中的元素了，删除、增加、修改都可以快速的完成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实施&quot;&gt;实施&lt;/h2&gt;
&lt;p&gt;有了思路后，就可以根据Chrome插件开发的步骤开始制作插件了，考虑到动画等动态性的内容并不是那么的重要，所以在保存页面的时候，去除了所有引入的js和js代码，这样做的另一个好处是减少文件大小。&lt;/p&gt;

&lt;h2 id=&quot;后续&quot;&gt;后续&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;目前尚未对引入的css进行合并，直接注入到页面中，可以完全不依赖网络，下个版本改进。&lt;/li&gt;
  &lt;li&gt;保留一些动画等元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;下载&quot;&gt;下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/just-one-file/opofajlgipfljhhlfhcpmhhjckjaacia?hl=zh-CN&amp;amp;authuser=1&quot;&gt;https://chrome.google.com/webstore/detail/just-one-file/opofajlgipfljhhlfhcpmhhjckjaacia?hl=zh-CN&amp;amp;authuser=1&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 30 May 2017 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2017/05/30/chrome-plugin-for-save/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2017/05/30/chrome-plugin-for-save/</guid>
        
        <category>web</category>
        
        
      </item>
    
      <item>
        <title>深入浅出单实例Singleton模式</title>
        <description>&lt;p&gt;单实例Singleton设计模式可能是被讨论和使用的最广泛的一个设计模式了，这可能也是面试中问得最多的一个设计模式了。这个设计模式主要目的是想在整个系统中只能出现一个类的实例。这样做当然是有必然的，比如你的软件的全局配置信息，或者是一个Factory，或是一个主控类等等。&lt;/p&gt;

&lt;p&gt;本文会带着你深入整个Singleton的世界,下面从几个版本来进行分析。&lt;/p&gt;

&lt;h3 id=&quot;1-singleton教学版本&quot;&gt;1. Singleton教学版本&lt;/h3&gt;

&lt;p&gt;这里直接给出一个Singleton的简单实现，我们姑且把这个版本叫做1.0版，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.0
public class Singleton {
    private static Singleton singleton = null;
    
    private Singleton() {
    }
    
    public static Singleton getInstance() {
        if (singleton== null) {
            singleton= new Singleton();
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的实例中，我想说明下面几个Singleton的特点：（下面这些东西可能是尽人皆知的，没有什么新鲜的）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;私有（private）的构造函数，表明这个类是不可能形成实例了。这主要是怕这个类会有多个实例。&lt;/li&gt;
  &lt;li&gt;即然这个类是不可能形成实例，那么，我们需要一个静态的方式让其形成实例：getInstance()。注意这个方法是在new自己，因为其可以访问私有的构造函数，所以他是可以保证实例被创建出来的。&lt;/li&gt;
  &lt;li&gt;在getInstance()中，先做判断是否已形成实例，如果已形成则直接返回，否则创建实例。&lt;/li&gt;
  &lt;li&gt;所形成的实例保存在自己类中的私有成员中。&lt;/li&gt;
  &lt;li&gt;我们取实例时，只需要使用Singleton.getInstance()就行了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，如果你觉得知道了上面这些事情后就学成了，那得给你当头棒喝一下了，事情远远没有那么简单。&lt;/p&gt;

&lt;h3 id=&quot;2-singleton实际版本&quot;&gt;2. Singleton实际版本&lt;/h3&gt;

&lt;p&gt;上面的这个程序存在比较严重的问题，因为是全局性的实例，所以，在多线程情况下，所有的全局共享的东西都会变得非常的危险，这个也一样，在多线程情况下，如果多个线程同时调用getInstance()的话，那么，可能会有多个进程同时通过 (singleton== null)的条件检查，于是，多个实例就创建出来，并且很可能造成内存泄露问题。嗯，熟悉多线程的你一定会说——“我们需要线程互斥或同步”，没错，我们需要这个事情，于是我们的Singleton升级成1.1版，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.1
public class Singleton
{
    private static Singleton singleton = null;
    
    private Singleton() {
    }
    
    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                singleton = new Singleton();
            }
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嗯，使用了Java的synchronized方法，看起来不错哦。应该没有问题了吧？！错！这还是有问题！为什么呢？前面已经说过，如果有多个线程同时通过(singleton== null)的条件检查（因为他们并行运行），虽然我们的synchronized方法会帮助我们同步所有的线程，让我们并行线程变成串行的一个一个去new，那不还是一样的吗？同样会出现很多实例。嗯，确实如此！看来，还得把那个判断(singleton== null)条件也同步起来。于是，我们的Singleton再次升级成1.2版本，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.2
public class Singleton
{
    private static Singleton singleton = null;
    
    private Singleton()  {
    }
    
    public static Singleton getInstance()  {
        synchronized (Singleton.class) {
            if (singleton == null) {
               singleton = new Singleton();
            }
         }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不错不错，看似很不错了。在多线程下应该没有什么问题了，不是吗？的确是这样的，1.2版的Singleton在多线程下的确没有问题了，因为我们同步了所有的线程。只不过嘛……，什么？！还不行？！是的，还是有点小问题，我们本来只是想让new这个操作并行就可以了，现在，只要是进入getInstance()的线程都得同步啊，注意，创建对象的动作只有一次，后面的动作全是读取那个成员变量，这些读取的动作不需要线程同步啊。这样的作法感觉非常极端啊，为了一个初始化的创建动作，居然让我们达上了所有的读操作，严重影响后续的性能啊！&lt;/p&gt;

&lt;p&gt;还得改！嗯，看来，在线程同步前还得加一个(singleton== null)的条件判断，如果对象已经创建了，那么就不需要线程的同步了。OK，下面是1.3版的Singleton：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.3
public class Singleton
{
    private static Singleton singleton = null;
    
    private Singleton()  {
    }
    
    public static Singleton getInstance() {
        if (singleton == null)  {
            synchronized (Singleton.class) {
                if (singleton == null)  {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;感觉代码开始变得有点罗嗦和复杂了，不过，这可能是最不错的一个版本了，这个版本又叫“双重检查”Double-Check。下面是说明：&lt;/p&gt;

&lt;p&gt;第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。
不然，我们就开始同步线程。
第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。
相当不错啊，干得非常漂亮！请大家为我们的1.3版起立鼓掌！&lt;/p&gt;

&lt;p&gt;但是，如果你认为这个版本大攻告成，你就错了。&lt;/p&gt;

&lt;p&gt;主要在于 &lt;code&gt;singleton = new Singleton()&lt;/code&gt; 这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给 singleton 分配内存&lt;/li&gt;
  &lt;li&gt;调用 Singleton 的构造函数来初始化成员变量，形成实例&lt;/li&gt;
  &lt;li&gt;将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。&lt;/p&gt;

&lt;p&gt;对此，我们只需要把singleton声明成 volatile 就可以了。下面是1.4版：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.4
public class Singleton
{
    private volatile static Singleton singleton = null;
    
    private Singleton()  {
    }
    
    public static Singleton getInstance()   {
        if (singleton == null)  {
            synchronized (Singleton.class) {
                if (singleton == null)  {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 volatile 有两个功用：&lt;/p&gt;

&lt;p&gt;1）这个变量不会在多个线程中存在复本，直接从内存读取。&lt;/p&gt;

&lt;p&gt;2）这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。&lt;/p&gt;

&lt;p&gt;但是，这个事情仅在Java 1.5版后有用，1.5版之前用这个变量也有问题，因为老版本的Java的内存模型是有缺陷的。&lt;/p&gt;

&lt;h3 id=&quot;3-singleton简化版本&quot;&gt;3. Singleton简化版本&lt;/h3&gt;

&lt;p&gt;上面的玩法实在是太复杂了，一点也不优雅，下面是一种更为优雅的方式：&lt;/p&gt;

&lt;p&gt;这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.5
public class Singleton
{
    private volatile static Singleton singleton = new Singleton();
    
    private Singleton()  {
    }
    
    public static Singleton getInstance()   {
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，这种玩法的最大问题是——当这个类被加载的时候，new Singleton() 这句话就会被执行，就算是getInstance()没有被调用，类也被初始化了。&lt;/p&gt;

&lt;p&gt;于是，这个可能会与我们想要的行为不一样，比如，我的类的构造函数中，有一些事可能需要依赖于别的类干的一些事（比如某个配置文件，或是某个被其它类创建的资源），我们希望他能在我第一次getInstance()时才被真正的创建。这样，我们可以控制真正的类创建的时刻，而不是把类的创建委托给了类装载器。&lt;/p&gt;

&lt;p&gt;好吧，我们还得绕一下：&lt;/p&gt;

&lt;p&gt;下面的这个1.6版是老版《Effective Java》中推荐的方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.6
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    private Singleton (){
    }
    
    public static final Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这种方式，仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。&lt;/p&gt;

&lt;h3 id=&quot;4-singleton优雅版本&quot;&gt;4. Singleton优雅版本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public enum Singleton{
   INSTANCE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;居然用枚举！！看上去好牛逼，通过EasySingleton.INSTANCE来访问，这比调用getInstance()方法简单多了。&lt;/p&gt;

&lt;p&gt;默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。&lt;/p&gt;

&lt;p&gt;这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。&lt;/p&gt;

&lt;h3 id=&quot;5-其他&quot;&gt;5. 其他&lt;/h3&gt;

&lt;p&gt;Singleton的其它问题可以从原文中查看。&lt;/p&gt;

&lt;p&gt;转载自&lt;a href=&quot;http://coolshell.cn/articles/265.html&quot;&gt;http://coolshell.cn/articles/265.html&lt;/a&gt;的部分,作者陈浩，本文进行了轻微改动。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 07 Feb 2017 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2017/02/07/head-first-singleton/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2017/02/07/head-first-singleton/</guid>
        
        <category>java</category>
        
        <category>pattern</category>
        
        
      </item>
    
      <item>
        <title>Hexo search组件</title>
        <description>&lt;p&gt;当前主流的静态博客有Jekyll和Hexo，之前的文章已经介绍了Jekyll中的搜索组件&amp;lt;&lt;a href=&quot;/2016/01/18/jekyll-search-component/&quot;&gt;Jekyll search组件&lt;/a&gt;&amp;gt;,本文来介绍下hexo博客中怎么添加搜索组件，组件项目地址&lt;a href=&quot;https://github.com/androiddevelop/hexo-search&quot;&gt;https://github.com/androiddevelop/hexo-search&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;截图&quot;&gt;截图&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/jekyll-search.jpg&quot; alt=&quot;jekyll-search.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;双击ctrl或者点击右下角搜索图标查看效果&lt;/p&gt;

&lt;h3 id=&quot;操作&quot;&gt;操作&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;点击右下角图标进行搜索&lt;/li&gt;
  &lt;li&gt;双击ctrl键进行搜索或关闭&lt;/li&gt;
  &lt;li&gt;搜索页面点击右上角关闭按钮关闭搜索试图&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;加入步骤&quot;&gt;加入步骤&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装搜索插件:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; npm install hexo-search-data-plugin --save
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将search目录放至于hexo主题的&lt;code&gt;source&lt;/code&gt;文件夹下，其中search目录结构如下:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; search
 ├── cb-footer-add.html
 ├── css
 │   └── cb-search.css
 ├── img
 │   ├── cb-close.png
 │   └── cb-search.png
 └── js
     ├── bootstrap3-typeahead.min.js
     └── cb-search.js
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在当前主题的&lt;code&gt;layout/_partial/after-footer.ejs&lt;/code&gt; 中的末尾加入 &lt;code&gt;cb-footer-add.html&lt;/code&gt; 中的内容即可, 添加完毕后 &lt;code&gt;cb-footer-add.html&lt;/code&gt; 文件可以删除。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果主题不存在&lt;code&gt;after-footer.ejs&lt;/code&gt;文件，也可以添加在&lt;code&gt;footer.ejs&lt;/code&gt;中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;bootstrap3-typeahead.min.js&lt;/code&gt; 的引入必须在&lt;code&gt;jquery.min.js&lt;/code&gt;引入之后!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;默认联想8个，如果需要更多的话，请检索 &lt;code&gt;bootstrap3-typeahead.min.js&lt;/code&gt; 中的&lt;strong&gt;items:8&lt;/strong&gt;, 将&lt;strong&gt;8&lt;/strong&gt;替换成自己需要的数值。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 29 Nov 2016 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2016/11/29/hexo-search-component/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2016/11/29/hexo-search-component/</guid>
        
        <category>web</category>
        
        
      </item>
    
      <item>
        <title>Android导航栏隐藏与浮现(二)</title>
        <description>&lt;p&gt;在&lt;a href=&quot;/2015/10/22/android-navigation-bar-immerse/&quot;&gt;Android导航栏隐藏与浮现(一)&lt;/a&gt;中已经以 &lt;code&gt;Nexus5&lt;/code&gt; 为例，&lt;code&gt;Android M&lt;/code&gt; 为基础介绍了怎么实现底部导航栏的隐藏与浮现，本文将介绍怎么在设置(辅助功能)中加入控制该功能的开关。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/android-navigation-enhance.png&quot; style=&quot;max-width:49.5%;  clear: both;  display: block;  margin:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图可以看到，应用中加入了一个 &lt;code&gt;Enhance Navigation bar&lt;/code&gt; 的选项，该功能开启后可以长点击任务键(Recent)时，导航栏隐藏；从下不向上滑时，导航栏展示。 关闭后即取消了该功能。下面看一下整体的操作步骤:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;添加试图到相应布局&lt;/li&gt;
  &lt;li&gt;实现状态保存，控制逻辑&lt;/li&gt;
  &lt;li&gt;在导航栏的操作中判断开关状态&lt;/li&gt;
  &lt;li&gt;编译打包&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;添加试图&quot;&gt;添加试图&lt;/h3&gt;

&lt;h4 id=&quot;-添加中文资源名称&quot;&gt;① 添加中文资源名称&lt;/h4&gt;

&lt;p&gt;在 &lt;code&gt;Settings.apk&lt;/code&gt; 中修改相应的资源文件即可，修改中可以参考系统设置中的 &lt;code&gt;Large text&lt;/code&gt;, 步骤如下：&lt;/p&gt;

&lt;p&gt;修改 &lt;code&gt;./packages/apps/Settings/res/values-zh-rCN/strings.xml&lt;/code&gt;，添加资源名称：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;string name=&quot;accessibility_toggle_enhance_navigation_bar_preference_title&quot;&amp;gt;&quot;增强导航栏功能&quot;&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;-添加英文资源名称&quot;&gt;② 添加英文资源名称&lt;/h4&gt;

&lt;p&gt;修改 &lt;code&gt;./packages/apps/Settings/res/values/strings.xml&lt;/code&gt;，添加资源名称：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;string name=&quot;accessibility_toggle_enhance_navigation_bar_preference_title&quot;&amp;gt;Enhance navigation bar&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;-添加选择开关&quot;&gt;③ 添加选择开关&lt;/h4&gt;

&lt;p&gt;修改 &lt;code&gt;./packages/apps/Settings/res/xml/accessibility_settings.xml&lt;/code&gt;，添加开关：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;SwitchPreference
  android:key=&quot;toggle_enhance_navigation_bar_preference&quot;
  android:title=&quot;@string/accessibility_toggle_enhance_navigation_bar_preference_title&quot;
  android:persistent=&quot;false&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;位置自己可以定义，文本放置在&lt;code&gt;Large text&lt;/code&gt;功能下方。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;控制逻辑&quot;&gt;控制逻辑&lt;/h3&gt;

&lt;h4 id=&quot;-添加开关字段&quot;&gt;① 添加开关字段&lt;/h4&gt;

&lt;p&gt;修改 &lt;code&gt;./frameworks/base/core/java/android/provider/Settings.java&lt;/code&gt;,在内部类&lt;code&gt;Secure&lt;/code&gt;中添加字段:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static final String ACCESSIBILITY_ENHANCE_NAVIGATION_BAR = &quot;enhance_navigation_bar&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;-添加默认开关&quot;&gt;② 添加默认开关&lt;/h4&gt;

&lt;p&gt;修改文件 &lt;code&gt;./frameworks/base/packages/SettingsProvider/res/values/defaults.xml&lt;/code&gt;,添加默认开关:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;bool name=&quot;def_accessibility_enhance_navigation_bar&quot;&amp;gt;false&amp;lt;/bool&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;-添加控制逻辑&quot;&gt;③ 添加控制逻辑&lt;/h4&gt;

&lt;p&gt;修改文件 &lt;code&gt;./packages/apps/Settings/src/com/android/settings/accessibility/AccessibilitySettings.java&lt;/code&gt;, 修改部分基本和 &lt;code&gt;Large text&lt;/code&gt; 的相同，diff后的试图如下，也可以根据下面提供修改前和修改后的文件，可以使用 &lt;code&gt;diff&lt;/code&gt; 工具对比查看。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/diff.html&quot;&gt;diff后的文件对比试图&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/file/AccessibilitySettings_before.java&quot;&gt;AccessibilitySettings修改前&lt;/a&gt;     &lt;a href=&quot;/file/AccessibilitySettings_after.java&quot;&gt;AccessibilitySettings修改后&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;读取状态控制功能开关&quot;&gt;读取状态，控制功能开关&lt;/h3&gt;

&lt;p&gt;修改 &lt;code&gt;./frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/PhoneStatusBar.java&lt;/code&gt;,添加变量:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private boolean enhanceNavigationSwitch = false; //默认关闭
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在recent键长点击处添加开关控制：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;try {
//读取开关状态
    enhanceNavigationSwitch = Settings.Secure.getInt(mContext.getContentResolver(), android.provider.Settings.Secure.ACCESSIBILITY_ENHANCE_NAVIGATION_BAR) == 1;
} catch (Settings.SettingNotFoundException e) {
    e.printStackTrace();
}
//开关关闭不进行任何操作
if (!enhanceNavigationSwitch) {
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;在&lt;code&gt;public boolean onLongClick(View view)&lt;/code&gt;的开始部分，用于判断是否执行长点击隐藏导航栏&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;编译打包&quot;&gt;编译打包&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;mmm&lt;/code&gt; 命令针对涉及的模块进行打包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;source build/envsetup.sh  //初始化环境变量
lunch //切换编译平台

mmm ./frameworks/base/packages/SettingsProvider

## 重新编译framework.jar
cd ./frameworks/base/core/
mm
cd ../../../

mmm ./frameworks/base/packages/SystemUI/
mmm ./packages/apps/Settings/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;make snod&lt;/code&gt; 命令生成 &lt;code&gt;system.img&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;两次的结合完整的解决了导航栏的隐藏与浮现以及功能控制。&lt;/p&gt;

&lt;p&gt;刷机需谨慎！刷机需谨慎！刷机需谨慎！如若刷机请提前备份数据！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 16 Sep 2016 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2016/09/16/android-navigation-bar-immerse-2/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2016/09/16/android-navigation-bar-immerse-2/</guid>
        
        <category>android</category>
        
        
      </item>
    
      <item>
        <title>Java泛型方法</title>
        <description>&lt;p&gt;Java在JDK 5中引入了泛型，使用起来方便了很多，下面是一段很常见的泛型使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;泛型方法使用&quot;&gt;泛型方法使用&lt;/h2&gt;

&lt;p&gt;不仅集合中可以使用，在定义类、接口和方法的时候也是经常使用的，但是关于泛型方法使用的场景还是不太多。下面从求两个数的最大数的实现上来看一下泛型类和泛型方法的简单使用：&lt;/p&gt;

&lt;h3 id=&quot;泛型类接口&quot;&gt;泛型类(接口)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package me.codeboy.test;

/**
 * generic test
 * Created by yuedong on 9/12/16.
 */
public class MathTest&amp;lt;T extends Comparable&amp;gt; {

    public static void main(String[] args) {
        MathTest&amp;lt;Integer&amp;gt; mathTest1 = new MathTest&amp;lt;Integer&amp;gt;();
        MathTest&amp;lt;Double&amp;gt; mathTest2 = new MathTest&amp;lt;Double&amp;gt;();
        System.out.println(mathTest1.max(1, 2));
        System.out.println(mathTest2.max(2.0, 3.0));
    }

    private T max(T t1, T t2) {
        return t1.compareTo(t2) &amp;gt; 0 ? t1 : t2;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;泛型方法&quot;&gt;泛型方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * generic test
 * Created by yuedong on 9/12/16.
 */
public class MathTest {

    public static void main(String[] args) {
        MathTest mathTest = new MathTest();
        System.out.println(mathTest.max(1, 2));
        System.out.println(mathTest.max(2.0, 3.0));
    }

    private &amp;lt;T extends Comparable&amp;gt; T max(T t1, T t2) {
        return t1.compareTo(t2) &amp;gt; 0 ? t1 : t2;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;静态泛型方法&quot;&gt;静态泛型方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * generic test
 * Created by yuedong on 9/12/16.
 */
public class MathTest {

    public static void main(String[] args) {
        System.out.println(max(1, 2));
        System.out.println(max(2.0, 3.0));
    }

    private static &amp;lt;T extends Comparable&amp;gt; T max(T t1, T t2) {
        return t1.compareTo(t2) &amp;gt; 0 ? t1 : t2;
    }
}


&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;泛型方法优缺点&quot;&gt;泛型方法优缺点&lt;/h2&gt;

&lt;p&gt;优点很明显，代码简洁多了，或者可以说比普通的泛型泛型更为简洁，网上有一段关于Android中频繁使用 &lt;code&gt;findViewById&lt;/code&gt; 方法的静态泛型方法实现，被称为见过最牛逼的Android代码，但是事物都有两面性，静态泛型方法也有相应的缺点，再看一段代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.List;

/**
 * test entry
 * Created by yuedong on 9/10/16.
 */
public class Test {

    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        list.add(&quot;test&quot;);

        //普通转换
        ArrayList&amp;lt;String&amp;gt; result1 = (ArrayList&amp;lt;String&amp;gt;) list;

        //静态泛型转换
        String result2 = convert(list);
    }

    private static &amp;lt;T&amp;gt; T convert(Object a) {
        return (T) a;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述代码是 &lt;strong&gt;编译通过，运行异常&lt;/strong&gt;，为什么会出现这种现象呢？这是因为Java的泛型方法属于伪泛型，在编译的时候将进行类型擦除。普通的泛型方法在类构建时已经明确制定了对应的类型，而在静态泛型方法中，类型是无法直接推测的，缺少了明确的类型，最终造成类型转化异常。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exception in thread &quot;main&quot; java.lang.ClassCastException: java.util.ArrayList cannot be cast to java.lang.String
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;原理探索&quot;&gt;原理探索&lt;/h2&gt;

&lt;p&gt;看到了上面的结果，不禁想了解下泛型方法在类型擦除后最终转换成了什么，反编译上述静态泛型方法编译后的class文件如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Compiled from &quot;Test.java&quot;
public class Test {
  public Test();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: new           #2                  // class java/util/ArrayList
       3: dup
       4: invokespecial #3                  // Method java/util/ArrayList.&quot;&amp;lt;init&amp;gt;&quot;:()V
       7: astore_1
       8: aload_1
       9: ldc           #4                  // String test
      11: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
      16: pop
      17: aload_1
      18: checkcast     #2                  // class java/util/ArrayList
      21: astore_2
      22: aload_1
      23: invokestatic  #6                  // Method convert:(Ljava/lang/Object;)Ljava/lang/Object;
      26: checkcast     #7                  // class java/lang/String
      29: astore_3
      30: return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到convert函数最终转化后对应的字节码为 &lt;code&gt;Method convert:(Ljava/lang/Object;)Ljava/lang/Object;&lt;/code&gt; 参数为Object类型，返回也为Object类型，而在接下来的 &lt;code&gt;checkcast&lt;/code&gt; 操作中，由于 &lt;code&gt;List&lt;/code&gt; 和 &lt;code&gt;String&lt;/code&gt; 类型的不同，所以抛出了异常。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    private static &amp;lt;T extends List&amp;gt; T convert(Object a) {
        return (T) a;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于上述的代码反编译后对应 &lt;code&gt;Method convert:(Ljava/lang/Object;)Ljava/util/List;&lt;/code&gt; 中，可以看到此时参数为Object类型，返回为List类型。&lt;/p&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;尽管Java中的泛型是伪泛型，但是泛型可以使代码更加的简洁，只是在使用 &lt;code&gt;普通泛型方法&lt;/code&gt; 和 &lt;code&gt;静态泛型方法&lt;/code&gt; 时需要特别注意类型转化。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 12 Sep 2016 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2016/09/12/java-generic-method/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2016/09/12/java-generic-method/</guid>
        
        <category>java</category>
        
        <category>android</category>
        
        
      </item>
    
  </channel>
</rss>
