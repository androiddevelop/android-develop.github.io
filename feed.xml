<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小胖轩</title>
    <description>编码生涯的点点滴滴</description>
    <link>https://https://www.codeboy.me/</link>
    <atom:link href="https://https://www.codeboy.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 07 Jan 2020 09:55:44 +0800</pubDate>
    <lastBuildDate>Tue, 07 Jan 2020 09:55:44 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>基于ElasticSearch的内容检索系统</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 是目前流行的电子书制作工具，很多文档基于此构建，团队内部文档也是一样的。由于模块比较的多且复杂，各个模块的文档分别对应一个&lt;code&gt;gitbook&lt;/code&gt;，职责明确了，但查找起来却麻烦很多，同时&lt;code&gt;gitbook&lt;/code&gt; 查看文档的方式相对简单，不能根据文档相关性进行排序。&lt;/p&gt;

&lt;h3 id=&quot;需求&quot;&gt;需求&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;多个gitbook文档能够提供统一查询入口&lt;/li&gt;
  &lt;li&gt;全文检索，根据相关性排序&lt;/li&gt;
  &lt;li&gt;提供文章访问热度&lt;/li&gt;
  &lt;li&gt;支持文章更新&lt;/li&gt;
  &lt;li&gt;支持搜索结果关联词高亮&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;设计&quot;&gt;设计&lt;/h3&gt;

&lt;p&gt;当前用于文档搜索的引擎有不少，比较流行的有&lt;code&gt;solr&lt;/code&gt;和&lt;code&gt;elasticSearch&lt;/code&gt;, 考虑到后者功能强大，配置简单，决定使用&lt;code&gt;elasticSearch&lt;/code&gt;(后文简称es)来存储文档，考虑到后续更灵活的扩展，使用&lt;code&gt;mysql&lt;/code&gt;记录文档访问次数，用于文章热度的获取以及自动联想等。&lt;/p&gt;

&lt;p&gt;系统包含以下几部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;gitbook爬虫&lt;/p&gt;

    &lt;p&gt;从gitbook中获取数据，存储/更新到es中，同时将标题、url存储/更新到mysql中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;es&lt;/p&gt;

    &lt;p&gt;存储/更新文档。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mysql&lt;/p&gt;

    &lt;p&gt;记录用户访问频次，提供输入框自动联想。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;技术点&quot;&gt;技术点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;中文分词&lt;/p&gt;

    &lt;p&gt;使用&lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-ik&quot;&gt;ik分词&lt;/a&gt;插件进行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;存储到es中&lt;/p&gt;

    &lt;p&gt;查询比较单一，没有使用es的The Java High Level REST Client，使用普通的查询完成通信。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询优化&lt;/p&gt;

    &lt;p&gt;考虑到标题相对比较短，并且比较简单，调整es查询时标题和内容的权重为1:2。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文档更新&lt;/p&gt;

    &lt;p&gt;根据文档的变更，自动完成对文档修改、删除。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;部署&quot;&gt;部署&lt;/h3&gt;

&lt;p&gt;参考&lt;a href=&quot;https://github.com/androiddevelop/DocSearch&quot;&gt;https://github.com/androiddevelop/DocSearch&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;demo页面&quot;&gt;Demo页面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/img/doc-search-home.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/img/doc-search-result.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;结合了&lt;code&gt;elasticSearch&lt;/code&gt;、&lt;code&gt;kibana(es数据展示)&lt;/code&gt; 、&lt;code&gt;mysql&lt;/code&gt;、&lt;code&gt;springboot&lt;/code&gt;等完成了文档检索，可以在搜索引擎触及不到的地方(内网)部署一个，方便多个地方的文档聚合。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 28 Sep 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/09/28/content-search-with-es/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/09/28/content-search-with-es/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>Andorid开发调试之run-as</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;Android开发中，经常会将一些文件放在内部目录中，即&lt;code&gt;/data/data/pacakge_id&lt;/code&gt;中，db文件也在该目录中 ，在非root的手机中，我们无法直接访问&lt;code&gt; /data/data&lt;/code&gt; 下的文件，调试起来非常的不方便，解决的办法有几种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;找一台root的手机，想看什么看什么&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;断点调试，可以稍微麻烦的看到本应用的目录及文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;run-as命令&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;前两种并不陌生，本文来讲解一下第三个&lt;code&gt;run-as&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;run-as&quot;&gt;run-as&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;run-as&lt;/code&gt; 命令可以获取debug应用的私有数据，在调试debug包的时候，可以使用该命令将用户切换到系统分配给debug应用的用户上，之后就可以访问其私有数据。下面以我的一个测试应用&lt;code&gt;me.codeboy.test&lt;/code&gt; 为例看一下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;➜ ~ adb shell
chiron:/ $ whoami
shell

chiron:/ $ ls /data/data/me.codeboy.test
ls: /data/data/me.codeboy.test: Permission denied

1|chiron:/ $ run-as me.codeboy.test
chiron:/data/data/me.codeboy.test $ ls
cache code_cache shared_prefs 

chiron:/data/data/me.codeboy.test $ whoami
u0_a279
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出在默认的shell环境下，用户身份是&lt;code&gt;shell&lt;/code&gt;，无法查看应用的私有数据，运行 &lt;code&gt;run-as&lt;/code&gt; 后，身份切换了 &lt;code&gt;u0_a279&lt;/code&gt;, 这个用户其实是测试应用的uid，也可以自由的访问其私有目录。&lt;/p&gt;

&lt;p&gt;Android中每一个应用都有一个uid，可以通过以下方式获取:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;try {
	PackageManager pm = getPackageManager();
	ApplicationInfo ai = pm.getApplicationInfo(&quot;me.codeboy.test&quot;, 0);
	Toast.makeText(MainActivity.this, Integer.toString(ai.uid,10), Toast.LENGTH_SHORT).show();
  } catch (PackageManager.NameNotFoundException e) {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后，输出的结果是10279。&lt;/p&gt;

&lt;p&gt;每个Android应用程序的u0_axxx都是不一样的，同时uid是从10000开始，u0_a后面的数字加上10000所得的值，既是uid，这个和测试应用的输出也非常的吻合，即&lt;code&gt;u0_a279&lt;/code&gt; 和 &lt;code&gt;10279&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;run-as&lt;/code&gt; 让可以在非root的手机上查看应用的私有目录，对开发调试来说非常的方便。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 10 Sep 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/09/10/android-run-as/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/09/10/android-run-as/</guid>
        
        <category>android</category>
        
        
      </item>
    
      <item>
        <title>Arrays.asList之UnsupportedOperationException</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;Java中经常会数组转化为List的场景，Java中的&lt;code&gt;Arrays&lt;/code&gt; 中提供了一个 &lt;code&gt;asList&lt;/code&gt; 方法可以快捷的转化，我们来看下面一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import java.util.Arrays;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        String a = &quot;a,a,a&quot;;
        List&amp;lt;String&amp;gt; list = Arrays.asList(a.split(&quot;,&quot;));
        list.add(&quot;b&quot;);
        System.out.println(list.size());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个会输出什么样的结果呢？&lt;/p&gt;

&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;

&lt;p&gt;运行后，程序抛出了异常，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException
	at java.util.AbstractList.add(AbstractList.java:148)
	at java.util.AbstractList.add(AbstractList.java:108)
	at me.codeboy.test.Test.main(Test.java:8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么会出现这个呢，我们查看下 &lt;code&gt;Arrays.asList&lt;/code&gt;  的代码:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; asList(T... a) {
	return new ArrayList&amp;lt;&amp;gt;(a);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的 &lt;code&gt;ArrayList&lt;/code&gt; 并非我们常用的 &lt;code&gt;java.util.ArrayList&lt;/code&gt;, 而是 &lt;code&gt;Arrays&lt;/code&gt; 中的一个内部类，同时这个内部类并没有实现 &lt;code&gt;add&lt;/code&gt; 、&lt;code&gt;remove&lt;/code&gt; 等操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt;
    implements RandomAccess, java.io.Serializable
{
    private static final long serialVersionUID = -2764017481108945198L;
    private final E[] a;

    ArrayList(E[] array) {
        a = Objects.requireNonNull(array);
    }

    @Override
    public int size() {
        return a.length;
    }

    @Override
    public Object[] toArray() {
        return a.clone();
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public &amp;lt;T&amp;gt; T[] toArray(T[] a) {
        int size = size();
        if (a.length &amp;lt; size)
            return Arrays.copyOf(this.a, size,
                                 (Class&amp;lt;? extends T[]&amp;gt;) a.getClass());
        System.arraycopy(this.a, 0, a, 0, size);
        if (a.length &amp;gt; size)
            a[size] = null;
        return a;
    }

    @Override
    public E get(int index) {
        return a[index];
    }

    @Override
    public E set(int index, E element) {
        E oldValue = a[index];
        a[index] = element;
        return oldValue;
    }

    @Override
    public int indexOf(Object o) {
        E[] a = this.a;
        if (o == null) {
            for (int i = 0; i &amp;lt; a.length; i++)
                if (a[i] == null)
                    return i;
        } else {
            for (int i = 0; i &amp;lt; a.length; i++)
                if (o.equals(a[i]))
                    return i;
        }
        return -1;
    }

    @Override
    public boolean contains(Object o) {
        return indexOf(o) != -1;
    }

    @Override
    public Spliterator&amp;lt;E&amp;gt; spliterator() {
        return Spliterators.spliterator(a, Spliterator.ORDERED);
    }

    @Override
    public void forEach(Consumer&amp;lt;? super E&amp;gt; action) {
        Objects.requireNonNull(action);
        for (E e : a) {
            action.accept(e);
        }
    }

    @Override
    public void replaceAll(UnaryOperator&amp;lt;E&amp;gt; operator) {
        Objects.requireNonNull(operator);
        E[] a = this.a;
        for (int i = 0; i &amp;lt; a.length; i++) {
            a[i] = operator.apply(a[i]);
        }
    }

    @Override
    public void sort(Comparator&amp;lt;? super E&amp;gt; c) {
        Arrays.sort(a, c);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;AbstractList&lt;/code&gt; 的实现中，默认 &lt;code&gt;add&lt;/code&gt;、 &lt;code&gt;remove&lt;/code&gt;方法的实现是抛出异常，这下就明白了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public void add(int index, E element) {
    throw new UnsupportedOperationException();
}
public void remove(int index) {
    throw new UnsupportedOperationException();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;使用 &lt;code&gt;Arrays.asList&lt;/code&gt; 时，如果需要对结果进行修改，需要构建 &lt;code&gt;java.util.ArrayList&lt;/code&gt; 之后在进行操作，不能在 &lt;code&gt;Arrays.asList&lt;/code&gt; 的产物上直接进行操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 20 Aug 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/08/20/arrays-aslist-uoexception/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/08/20/arrays-aslist-uoexception/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>内容共享</title>
        <description>&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;

&lt;p&gt;工作时有两台主力电脑，一台Mac，一台Ubuntu，之前经常基本上是Mac共享内容给Ubuntu，也有了&lt;a href=&quot;/2019/04/17/clipboard-sync&quot;&gt;剪切板同步&lt;/a&gt;这篇文章。随着Ubuntu上做的事情越来越多，也需要反向共享，结合日常工作中也需要和很多业务方同学来进行文本、图片的共享，于是决定做一个简单内容共享的Web应用。&lt;/p&gt;

&lt;h3 id=&quot;目标&quot;&gt;目标&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;多设备间可以访问，共享文本和图片。&lt;/li&gt;
  &lt;li&gt;支持房间，可以针对特定的共享有单独的区域。&lt;/li&gt;
  &lt;li&gt;支持设置访问密码。(目前暂不支持)&lt;/li&gt;
  &lt;li&gt;PC端直接粘贴即可，提升效率。&lt;/li&gt;
  &lt;li&gt;自动清理信息，清理24小时内没有任何访问的房间。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;demo&quot;&gt;Demo&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://share.codeboy.org&quot;&gt;share.codeboy.org&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;部署&quot;&gt;部署&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;下载&lt;a href=&quot;http://cdn.codeboy.org/clipboard-0.0.1.jar&quot;&gt;clipboard-0.0.1.jar&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;执行以下命令即可
    &lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;java -jar clipboard-0.0.1.jar
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;默认80端口，如果需要修改，可以 &lt;code&gt;application.properties&lt;/code&gt; 中端口号即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;二次开发&quot;&gt;二次开发&lt;/h3&gt;

&lt;p&gt;项目基于 &lt;code&gt;SpringBoot&lt;/code&gt; + &lt;code&gt;thymeleaf&lt;/code&gt; 开发，可以在此基础上进一步改造。
项目地址： &lt;a href=&quot;https://github.com/androiddevelop/ContentShare&quot;&gt;https://github.com/androiddevelop/ContentShare&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 29 Jul 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/07/29/content-share/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/07/29/content-share/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>HashSet.add覆盖问题</title>
        <description>&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;

&lt;p&gt;假定对象A、B的hash值相同，equals方法也想等，那么向 &lt;code&gt;HashSet&lt;/code&gt; 中顺序添加A、B，最后集合中保留的是A或者B或者是A和B呢？&lt;/p&gt;

&lt;h3 id=&quot;编码&quot;&gt;编码&lt;/h3&gt;

&lt;p&gt;看以下代码，分析下输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.hash;

import java.util.Objects;

/**
 * hash bean
 * Created by yuedong.li on 2019-07-01
 */
public class HashBean {
    String value;

    @Override
    public boolean equals(Object obj) {
        return true;
    }

    @Override
    public int hashCode() {
        return Objects.hash(&quot;test&quot;);
    }

    @Override
    public String toString() {
        return value;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.hash;

import com.google.common.collect.Maps;

import java.util.HashSet;
import java.util.Map;

/**
 * set add问题
 * Created by yuedong.li on 2019-07-01
 */
public class SetAdd {
    public static void main(String[] args) {
        HashBean bean = new HashBean();
        bean.value = &quot;first&quot;;
        HashBean bean2 = new HashBean();
        bean2.value = &quot;second&quot;;

        HashSet&amp;lt;HashBean&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        set.add(bean);
        set.add(bean2);
        System.out.println(set.size());
        System.out.println(set.iterator().next().value);

        System.out.println();
        Map&amp;lt;HashBean, String&amp;gt; map2 = Maps.newHashMap();
        map2.put(bean, &quot;first&quot;);
        map2.put(bean2, &quot;second&quot;);
        System.out.println(map2.size());
        System.out.println(map2.values().iterator().next());
        System.out.println(map2.keySet().iterator().next());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;

&lt;p&gt;这里先贴一下输出的结果:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;1
first

1
second
first
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么会是这样的呢？我们先看一下Jdk1.8.0中 &lt;code&gt;HashSet.add&lt;/code&gt; 方法的调用栈:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;## HashSet
public boolean add(E e) {
	return map.put(e, PRESENT)==null;  //这里直接使用的是hashMap，将值当作key记录
}

## HashMap 
/**
 * Associates the specified value with the specified key in this map.
 * If the map previously contained a mapping for the key, the old
 * value is replaced.
 *
 * @param key key with which the specified value is to be associated
 * @param value value to be associated with the specified key
 * @return the previous value associated with &amp;lt;tt&amp;gt;key&amp;lt;/tt&amp;gt;, or
 *         &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; if there was no mapping for &amp;lt;tt&amp;gt;key&amp;lt;/tt&amp;gt;.
 *         (A &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; return can also indicate that the map
 *         previously associated &amp;lt;tt&amp;gt;null&amp;lt;/tt&amp;gt; with &amp;lt;tt&amp;gt;key&amp;lt;/tt&amp;gt;.)
 */
public V put(K key, V value) {
  return putVal(hash(key), key, value, false, true);
}

/**
 * Implements Map.put and related methods
 *
 * @param hash hash for key
 * @param key the key
 * @param value the value to put
 * @param onlyIfAbsent if true, don't change existing value
 * @param evict if false, the table is in creation mode.
 * @return previous value, or null if none
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&amp;lt;K,V&amp;gt; e; K k;
        if (p.hash == hash &amp;amp;&amp;amp;
            ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    if (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &amp;amp;&amp;amp;
                    ((k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        if (e != null) { // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    ++modCount;
    if (++size &amp;gt; threshold)
        resize();
    afterNodeInsertion(evict的);
    return null;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码中可以看出，&lt;code&gt;HashSet.add&lt;/code&gt; 直接调用&lt;code&gt;HashMap.put&lt;/code&gt; 方法，&lt;code&gt;HashSet&lt;/code&gt;的内部实现也确实是&lt;code&gt;HashMap&lt;/code&gt;,  &lt;code&gt;HashSet.add&lt;/code&gt; 的值直接作为&lt;code&gt;HashMap&lt;/code&gt;的key进行存储，从&lt;code&gt;HashMap.putVal&lt;/code&gt; 方法中可以看出，&lt;code&gt;HashMap&lt;/code&gt;的key并没有做替换，在 &lt;code&gt;onlyIfAbsent&lt;/code&gt;是false或者原先值为null的情况下，新value会替换旧value。&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;HashSet&lt;/code&gt;在add的时候，在两个对象相等的情况下，是不进行替换的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt;在put的时候，在两个key相等的情况下，是不进行替换的，在两个value相同的情况下，是要根据 &lt;code&gt;putVal&lt;/code&gt; 方法中的&lt;code&gt;onlyIfAbsent&lt;/code&gt;字段进行决定的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 04 Jul 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/07/04/hashset-add/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/07/04/hashset-add/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>Andorid AppLink配置</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;客户端开发中，经常会遇到appA跳转appB的场景，之前Android中使用比较多的是 &lt;code&gt;DeepLink&lt;/code&gt;，ios中对应的是 &lt;code&gt;Scheme&lt;/code&gt;, 两者基本类似，在用户触发某个操作后，系统提示是否打开对应app，用户选择同意后进入指定app。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DeepLink&lt;/code&gt; 一方面流程上稍微长一些，另一方面存在scheme 被别人占用等问题，在Android6.0，有了 &lt;code&gt;AppLink&lt;/code&gt;, 可以完美解决上述两个问题，与之对应的ios平台9.0上的加入的 &lt;code&gt;Universal Links&lt;/code&gt;。 &lt;code&gt;AppLink&lt;/code&gt; 在系统验证过服务端上配置的的证书(keystore)信息后，在6.0+上可以一步到达对应的应用，6.0以下系统降级为普通的 &lt;code&gt;DeepLink&lt;/code&gt;，下面来看下怎么使用 &lt;code&gt;AppLink&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;服务端配置&quot;&gt;服务端配置&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;AppLink&lt;/code&gt; 需要将应用的keystore签名对应的sha哈希值配置到域名对应的指定目录，以本站域名为例，需要是以下地址:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;https://www.codeboy.me/.well-known/assetlinks.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内容是固定的，配置下应用的package和对应签名的sha哈希即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;[
  {
    &quot;relation&quot;: [&quot;delegate_permission/common.handle_all_urls&quot;],
    &quot;target&quot;: {
      &quot;namespace&quot;: &quot;android_app&quot;,
      &quot;package_name&quot;: &quot;me.codeboy.test&quot;,
      &quot;sha256_cert_fingerprints&quot;: [
&quot;91:C1:DF:23:EB:37:91:5D:60:9E:FA:19:3F:BF:B1:4B:72:A5:97:AC:F2:16:17:66:8F:56:44:CB:3A:18:A3:39&quot;
      ]
    }
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;sha256_cert_fingerprints&lt;/code&gt;可以根据以下命令获取:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;keytool -list -v -keystore debug.keystore
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;客户端配置&quot;&gt;客户端配置&lt;/h3&gt;

&lt;p&gt;客户端上需要给对应的Activity配置上intent-filter即可,  如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;&amp;lt;intent-filter android:autoVerify=&quot;true&quot;&amp;gt;
    &amp;lt;action android:name=&quot;android.intent.action.VIEW&quot; /&amp;gt;
    &amp;lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&amp;gt;
    &amp;lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&amp;gt;
    &amp;lt;data android:host=&quot;www.codeboy.me&quot;
          android:scheme=&quot;https&quot; /&amp;gt;
&amp;lt;/intent-filter&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;对于参数上的解析，可以直接从intent中获取即可。&lt;/li&gt;
  &lt;li&gt;配置多个域名，需要每一个域名下对应的assetlinks.json均验证通过。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;applink测试&quot;&gt;AppLink测试&lt;/h3&gt;

&lt;p&gt;测试的方式有很多，可以编辑一条短信，也可以直接adb进行查看，这里通过adb验证:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;am start -a android.intent.action.VIEW -d https://www.codeboy.me
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;应用直接进入测试客户端。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果配置多个域名，必须每个域名均校验通过，不然AppLink会降级为普通的DeppLink。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;AppLink使得用户的体验更好，有条件能支持的话还是支持一下比较好。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 29 Jun 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/06/29/android-app-link/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/06/29/android-app-link/</guid>
        
        <category>android</category>
        
        
      </item>
    
      <item>
        <title>Javascript的undefined和null</title>
        <description>&lt;p&gt;Javascript中的 &lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 非常的常见，它们有什么不同呢？首先看几个简单的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;var a = undefined;
var b = null;
console.log(a == b);
console.log(a === b);
console.log(typeof(a) == typeof(b));
console.log(a + 1);
console.log(b + 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的5个console日志会输出什么？&lt;/p&gt;

&lt;h3 id=&quot;解析&quot;&gt;解析&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;undefined&lt;/code&gt; 在javascript中表示一个没有设置值的变量， &lt;code&gt;null&lt;/code&gt; 表示一个空对象引用。从表示含义上可以很清楚的区分两者， 不过两者在部分使用上有一些差异，如下表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特征&lt;/th&gt;
      &lt;th&gt;undefined&lt;/th&gt;
      &lt;th&gt;null&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;含义&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
      &lt;td&gt;空对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表示数据&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;类型&lt;/td&gt;
      &lt;td&gt;undefined&lt;/td&gt;
      &lt;td&gt;object&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以上几个示例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;var a = undefined;
var b = null;
console.log(a == b);   // true
console.log(a === b);   // false
console.log(typeof(a) == typeof(b));   // false
console.log(a + 1);    // NaN
console.log(b + 1);  // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;针对这两个的经典场景，在阮一峰老师的文章&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html&quot;&gt;undefined与null的区别&lt;/a&gt;中给出了说明，这里引用一下。&lt;/p&gt;

&lt;h4 id=&quot;null典型用法&quot;&gt;null典型用法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;undefined典型用法&quot;&gt;undefined典型用法&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;（1）变量被声明了，但没有赋值时，就等于undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。
（3）对象没有赋值的属性，该属性的值为undefined。
（4）函数没有返回值时，默认返回undefined。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;undefined&lt;/code&gt; 和 &lt;code&gt;null&lt;/code&gt; 在javascript中的含义相近，存在差异， &lt;code&gt;undefined&lt;/code&gt; 的场景更多一些。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 17 Jun 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/06/17/js-undefined-and-null/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/06/17/js-undefined-and-null/</guid>
        
        <category>web</category>
        
        
      </item>
    
      <item>
        <title>Java源码在线编译执行</title>
        <description>&lt;p&gt;在告警平台中，经常会用到规则配置，一些简单的规则配置可以使用基本表达式来完成，对于一些复杂的规则，很难进行表达或者完全覆盖，如果告警规则等由一些具备编程能力的开发同学来完成，是否可以考虑规则直接使用源码来描述，动态执行呢？这样可以在系统不重新部署的情况下加入新的规则配置。&lt;/p&gt;

&lt;p&gt;下面我们根据 &lt;code&gt;JDK6&lt;/code&gt; 中新增的 &lt;code&gt;JavaCompiler&lt;/code&gt; ，来实现源码线上编译，完成简单类的线上运行，并获取对应的结果。&lt;/p&gt;

&lt;h3 id=&quot;约定&quot;&gt;约定&lt;/h3&gt;

&lt;p&gt;约定测试类需要实现无参 &lt;code&gt;execute&lt;/code&gt; 方法，在编译成功后，使用反射的方法调用该方法。下面是我们用来测试的一个代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.compile;

/**
 * 测试class
 * Created by yuedong.li on 2019-06-14
 */
public class FooClass {

    public String execute() {
        System.out.println(&quot;invoke method&quot;);
        return &quot;SUCCESS&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印 &lt;code&gt;invoke method&lt;/code&gt; , 并返回对应 &lt;code&gt;SUCCESS&lt;/code&gt; 结果。&lt;/p&gt;

&lt;h3 id=&quot;准备&quot;&gt;准备&lt;/h3&gt;

&lt;p&gt;编译java代码需要指定编译参数和classpath，使用 &lt;code&gt;JavaCompiler&lt;/code&gt; 也是一样的，需要把执行测试类的一些基础依赖添加到编译环境中来，针对本文中的示例，使用基本配置即可，作者测试时使用的配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  编译参数:  -target 1.8
classpath: 工程中的其他的class作为classpath
  输出目录: 工程根目录下的CodeTest目录
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;操作&quot;&gt;操作&lt;/h3&gt;

&lt;h4 id=&quot;定义javafileobject&quot;&gt;定义JavaFileObject&lt;/h4&gt;

&lt;p&gt;用于保存源码，jdk中提供了 &lt;code&gt;SimpleJavaFileObject&lt;/code&gt; , 可以在该类的基础上简单修改即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.compile;

import javax.tools.SimpleJavaFileObject;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.net.URI;

/**
 * java file object
 * Created by yuedong.li on 2019-06-13
 */
public class MyJavaFileObject extends SimpleJavaFileObject {
    private String source;

    public MyJavaFileObject(String name, String source) {
        super(URI.create(&quot;String:///&quot; + name + Kind.SOURCE.extension), Kind.SOURCE);
        this.source = source;
    }

    @Override
    public CharSequence getCharContent(boolean ignoreEncodingErrors) {
        if (source == null) {
            throw new IllegalArgumentException(&quot;source == null&quot;);
        }
        return source;
    }

    @Override
    public OutputStream openOutputStream() {
        return new ByteArrayOutputStream();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;定义classloader&quot;&gt;定义classloader&lt;/h4&gt;

&lt;p&gt;加载字节码，为什么定义呢，因为 &lt;code&gt;defineClass&lt;/code&gt; 是 &lt;code&gt;protected&lt;/code&gt; 修饰的, 实际上是做一个中转。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.compile;

/**
 * classLoader，在当前classLoader的基础上，load进来自己载入的类
 * Created by yuedong.li on 2019-06-13
 */
public class MyClassLoader extends ClassLoader {

    public MyClassLoader() {
        super(MyClassLoader.class.getClassLoader());
    }

    Class&amp;lt;?&amp;gt; getTestClass(byte[] classBytes) {
        return defineClass(null, classBytes, 0, classBytes.length);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;coderuntime&quot;&gt;CodeRuntime&lt;/h4&gt;

&lt;p&gt;源码执行器，进行的操作如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;源码去除package头部&lt;/li&gt;
  &lt;li&gt;获取className&lt;/li&gt;
  &lt;li&gt;为生成的class指定目录&lt;/li&gt;
  &lt;li&gt;编译源码，生成字节码&lt;/li&gt;
  &lt;li&gt;加载字节码，反射调用execute方法&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test.compile;

import javax.tools.*;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * code runtime
 * Created by yuedong.li on 2019/06/14.
 */
public class CodeRuntime {
    private static final Pattern CLASS_PATTERN = Pattern.compile(&quot;class\\s+([$_a-zA-Z][$_a-zA-Z0-9]*)\\s*&quot;);
    private static final List&amp;lt;String&amp;gt; OPTIONS = new ArrayList&amp;lt;&amp;gt;(); // 编译参数
    private static final List&amp;lt;File&amp;gt; CLASSPATH = new ArrayList&amp;lt;&amp;gt;(); // classpath
    private static final String PROJECT_DIR = System.getProperty(&quot;user.dir&quot;); // 工程目录
    private static final String TMP_DIR = &quot;CodeTest&quot;; // 存储编译产物

    static {
        OPTIONS.add(&quot;-target&quot;);
        OPTIONS.add(&quot;1.8&quot;);
        File classRootFile = new File(PROJECT_DIR, TMP_DIR);
        if (!classRootFile.exists()) {
            classRootFile.mkdir();
        }
        //根据实际情况添加对应的环境变量，class或者jar都可以
        CLASSPATH.add(new File(classRootFile, &quot;build/classes/main&quot;));
    }

    /**
     * 执行代码
     *
     * @param code 源码
     * @return 返回结果
     * @throws IOException io异常
     */
    public static String run(String code) throws IOException {
        if (code == null || code.length() == 0) {
            return &quot;代码为空&quot;;
        }
        code = code.trim();
        //去除package
        if (code.startsWith(&quot;package&quot;)) {
            int index = code.indexOf(&quot;\n&quot;);
            if (index != -1) {
                code = code.substring(index + 1);
            }
        }

        //找出入口类名
        Matcher matcher = CLASS_PATTERN.matcher(code);
        String clsName;
        if (matcher.find()) {
            clsName = matcher.group(1);
        } else {
            throw new IllegalArgumentException(&quot;No such class name in &quot; + code);
        }

        //在对应代码生成目录中以时间戳为目录名建立目录
        File classRootFile = new File(PROJECT_DIR, TMP_DIR);
        final String time = String.valueOf(System.currentTimeMillis());
        File parentDir = new File(classRootFile, time);
        if (!parentDir.exists()) {
            parentDir.mkdir();
        }

        File classFile = new File(parentDir, clsName + &quot;.class&quot;);
        File[] outputs = new File[]{parentDir};

        //开始进行编译
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        DiagnosticCollector&amp;lt;JavaFileObject&amp;gt; collector = new DiagnosticCollector&amp;lt;&amp;gt;();
        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);
        fileManager.setLocation(StandardLocation.CLASS_PATH, CLASSPATH);
        fileManager.setLocation(StandardLocation.CLASS_OUTPUT, Arrays.asList(outputs));

        JavaFileObject javaFileObject = new MyJavaFileObject(clsName, code);
        Boolean result = compiler.getTask(null, fileManager, collector, OPTIONS, null, Arrays.asList(javaFileObject)).call();
      
        //编译结果，如果有错误，返回对应错误信息
        if (!result) {
            List list = collector.getDiagnostics();
            StringBuilder info = new StringBuilder();
            for (Object object : list) {
                Diagnostic d = (Diagnostic) object;
                String line = d.getMessage(Locale.ENGLISH);
                info.append(line).append(&quot;\n&quot;);
            }
            String infoStr = info.toString();
            if (infoStr.endsWith(&quot;\n&quot;)) {
                infoStr = infoStr.substring(0, infoStr.length() - 1);
            }
            return &quot;编译失败:&quot; + infoStr;
        }

        //读取字节码，使用类加载器加载
        byte[] classBytes = getBytesFromFile(classFile);
        MyClassLoader classloader = new MyClassLoader();
        try {
            Class clazz = classloader.getTestClass(classBytes);
            Object instance = clazz.newInstance();

            Method method = clazz.getMethod(&quot;execute&quot;);
            return method.invoke(instance).toString();
        } catch (NoSuchMethodException e) {
            return &quot;请实现execute无参方法&quot;;
        } catch (Exception e2) {
            return e2.getMessage();
        }
    }

    /**
     * 文件转化为字节数组
     *
     * @param file 文件
     * @return 字节数组
     */
    private static byte[] getBytesFromFile(File file) throws IOException {
        if (file == null) {
            return null;
        }
        FileInputStream in = new FileInputStream(file);
        ByteArrayOutputStream out = new ByteArrayOutputStream(4096);
        byte[] b = new byte[4096];
        int n;
        while ((n = in.read(b)) != -1) {
            out.write(b, 0, n);
        }
        in.close();
        out.close();
        return out.toByteArray();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;

&lt;p&gt;对 &lt;code&gt;CoideRuntime&lt;/code&gt; 进行源码测试，将 &lt;code&gt;FooTest&lt;/code&gt; 类的源码作为字符串输入后执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  package me.codeboy.test.compile;
  
  import java.io.IOException;
  
  /**
   * 测试代码
   * Created by yuedong.li on 2019-06-13
   */
  public class Test {
      public static void main(String[] args) throws IOException {
          String source = &quot;package me.codeboy.test.compile;&quot; +
                  &quot;\n&quot; +
                  &quot;/**\n&quot; +
                  &quot; * 测试class\n&quot; +
                  &quot; * Created by yuedong.li on 2019-06-14\n&quot; +
                  &quot; */\n&quot; +
                  &quot;public class FooClass { \n&quot; +
                  &quot;    public String execute() {\n&quot; +
                  &quot;        System.out.println(\&quot;invoke method\&quot;);&quot; +
                  &quot;        return \&quot;SUCCESS\&quot;;&quot;+
                  &quot;    }&quot; +
                  &quot;}&quot;;
          String result = CodeRuntime.run(source);
          System.out.println(result);
      }
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后，输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;invoke method
SUCCESS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;符合预期结果。&lt;/p&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;根据上面的讲述，针对告警平台等的一些规则可以使用源码来编写，虽然需要一点开发成本，但是灵活度大幅度提升，遇到合适的场景可以考虑尝试。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Fri, 14 Jun 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/06/14/java-online-compile/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/06/14/java-online-compile/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>Java字符串单字符分割</title>
        <description>&lt;p&gt;Java中分割字符串经常会使用到 &lt;code&gt;String.split&lt;/code&gt; ，本文中针对单字符分割的场景进行简单讨论，首先看几个例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;&quot;&quot;.split(&quot;=&quot;)      //示例1
&quot;=&quot;.split(&quot;=&quot;)     //示例2
&quot;==&quot;.split(&quot;=&quot;)    //示例3
&quot;=&quot;.split(&quot;=&quot;, 1)  //示例4
&quot;=&quot;.split(&quot;=&quot;, 2)  //示例5
&quot;=&quot;.split(&quot;=&quot;, 4)  //示例6
&quot;=12=&quot;.split(&quot;=&quot;)  //示例7
&quot;&quot;.split(&quot;=&quot;, 1)   //示例8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上几个示例分割后的数组长度是多少呢？在本文小结中有结果，可以对比下是否和想象中的一致，有出入的话可以一起来看下源码。&lt;/p&gt;

&lt;h3 id=&quot;源码解析&quot;&gt;源码解析&lt;/h3&gt;

&lt;p&gt;基于jdk8来分析下 &lt;code&gt;String.split&lt;/code&gt; 方法，&lt;code&gt;String.split&lt;/code&gt;  有2个方法，分别如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public String[] split(String regex)   //方法1
public String[] split(String regex, int limit) // 方法2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中方法1直接调用方法2，传入&lt;code&gt;limit=0&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public String[] split(String regex) {
        return split(regex, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面具体看一下方法2的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public String[] split(String regex, int limit) {
  // 针对单字符分割，使用fastpath，没有使用正则java.util.regex.Pattern.split方法
  /* fastpath if the regex is a
    (1)one-char String and this character is not one of the
            RegEx's meta characters &quot;.$|()[{^?*+\\&quot;, or
    (2)two-char String and the first char is the backslash and
            the second is not the ascii digit or ascii letter.
  */
  char ch = 0;
  if (((regex.value.length == 1 &amp;amp;&amp;amp;
        &quot;.$|()[{^?*+\\&quot;.indexOf(ch = regex.charAt(0)) == -1) ||
       (regex.length() == 2 &amp;amp;&amp;amp;
        regex.charAt(0) == '\\' &amp;amp;&amp;amp;
        (((ch = regex.charAt(1))-'0')|('9'-ch)) &amp;lt; 0 &amp;amp;&amp;amp;
        ((ch-'a')|('z'-ch)) &amp;lt; 0 &amp;amp;&amp;amp;
        ((ch-'A')|('Z'-ch)) &amp;lt; 0)) &amp;amp;&amp;amp;
      (ch &amp;lt; Character.MIN_HIGH_SURROGATE ||
       ch &amp;gt; Character.MAX_LOW_SURROGATE))
  {
    int off = 0;
    int next = 0;
    // limit为0表示没有显示最大分割个数
    boolean limited = limit &amp;gt; 0;
    ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    while ((next = indexOf(ch, off)) != -1) {
      // 长度限制为1时，该条件不满足，直接进入else中，也即示例4、8的操作
      if (!limited || list.size() &amp;lt; limit - 1) {
        list.add(substring(off, next));
        off = next + 1;
      } else {    // last one
        //assert (list.size() == limit - 1);
        list.add(substring(off, value.length));
        off = value.length;
        break;
      }
    }
    // 示例1会进入的逻辑，因为示例1在上面的while中会直接跳出，off时默认值0
    // If no match was found, return this
    if (off == 0)
      return new String[]{this};

    //将最后一个添加进来
    // Add remaining segment
    if (!limited || list.size() &amp;lt; limit)
      list.add(substring(off, value.length));

    // 针对limit=0的场景，会循环去除最后一个空字符串，示例2、3会触发该条件
    // 为什么会针对limit=0的这种场景去除空字符串？感觉不能理解。
    // Construct result
    int resultSize = list.size();
    if (limit == 0) {
      while (resultSize &amp;gt; 0 &amp;amp;&amp;amp; list.get(resultSize - 1).length() == 0) {
        resultSize--;
      }
    }
    String[] result = new String[resultSize];
    return list.subList(0, resultSize).toArray(result);
  }
  //多字符串分割本文不讨论
  return Pattern.compile(regex).split(this, limit);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;p&gt;根据上面的例子, 我们可以看出，在不限定长度的情况下，split分割会去除数据末尾的所有空串。以上几种场景的结果如下:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;结果&lt;/th&gt;
      &lt;th&gt;长度&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;”“.split(“=”)  //示例1&lt;/td&gt;
      &lt;td&gt;[””]&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”=”.split(“=”)  //示例2&lt;/td&gt;
      &lt;td&gt;[]&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”==”.split(“=”)  //示例3&lt;/td&gt;
      &lt;td&gt;[]&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”=”.split(“=”, 1)  //示例4&lt;/td&gt;
      &lt;td&gt;[”=”]&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”=”.split(“=”, 2)  //示例5&lt;/td&gt;
      &lt;td&gt;[””, “”]&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”=”.split(“=”, 4)  //示例6&lt;/td&gt;
      &lt;td&gt;[””, “”]&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“=12=”.split(“=”)  //示例7&lt;/td&gt;
      &lt;td&gt;[””, “12”]&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;”“.split(“=”, 1)  //示例8&lt;/td&gt;
      &lt;td&gt;[””]&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 05 Jun 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/06/05/java-string-spilt/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/06/05/java-string-spilt/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>同域代理</title>
        <description>&lt;h3 id=&quot;前沿&quot;&gt;前沿&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;跨域请求&lt;/code&gt; 对于每一个前端开发应该都不会陌生，由于一些安全策略的限制，默认情况下浏览器不允许在一个域下请求另外一个域下的资源，例如 &lt;code&gt;www.codeboy.me&lt;/code&gt; 下请求 &lt;code&gt;test.codeboy.me&lt;/code&gt; 下的资源，相同的域要求协议、域名、端口都必须相同。&lt;/p&gt;

&lt;p&gt;当前解决的方案有以下几种:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-no_highlight&quot;&gt;1. JSONP
2. 同域请求
3. CORS(跨域资源共享)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;JSONP&lt;/code&gt; 和 &lt;code&gt;CORS&lt;/code&gt; 均需要服务端进行适当适配和改造，这里不再讲述，感兴趣的小伙伴可以自行查询。这里我们对同域请求的实现进行说明。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;同域请求&lt;/code&gt; ,顾名思义就是将相同域下的请求进行代理，其实是一种 &lt;code&gt;反向代理&lt;/code&gt; , 用最近项目开发中的一个例子来进行叙述和配置。前端页面部署在 &lt;code&gt;project.example.com&lt;/code&gt; 中，服务端代码也部署在该服务器上，但是端口是 &lt;code&gt;9999&lt;/code&gt; , 正常情况下，&lt;code&gt;http://project.example.com/test.html&lt;/code&gt; 页面中是访问不到 &lt;code&gt;http://project.example.com:9999/api/getData&lt;/code&gt; 的数据的，此时我们可以加一层代理，将  &lt;code&gt;http://project.example.com/api/getData&lt;/code&gt; 全部代理转发到  &lt;code&gt;http://project.example.com:9999/api/getData&lt;/code&gt; 即可。&lt;/p&gt;

&lt;h3 id=&quot;准备环境&quot;&gt;准备环境&lt;/h3&gt;

&lt;p&gt;鉴于长期使用 &lt;code&gt;Apache Server&lt;/code&gt; ，本次基于 &lt;code&gt;Apache 2.4.18&lt;/code&gt; 进行，后端所有的接口均有 &lt;code&gt;/api&lt;/code&gt; 开头。&lt;/p&gt;

&lt;h3 id=&quot;期待目标&quot;&gt;期待目标&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;正常访问 &lt;code&gt;http://project.example.com&lt;/code&gt; 可以请求到所有的静态资源&lt;/li&gt;
  &lt;li&gt;所有的 &lt;code&gt;http://project.example.com/api/**&lt;/code&gt; 的请求代理到 &lt;code&gt;http://project.example.com:9999/api/**&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;服务器配置&quot;&gt;服务器配置&lt;/h3&gt;

&lt;p&gt;在原有配置 &lt;code&gt;VirtualHost&lt;/code&gt; 目录中，增加对 &lt;code&gt;/api&lt;/code&gt;  的反向代理，由于同域，可以直接转发到 &lt;code&gt;127.0.0.1&lt;/code&gt; 上即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
	ServerAdmin admin@example.com
  ServerName project.example.com
	DocumentRoot /var/www/example
 
	&amp;lt;Directory /var/www/example&amp;gt;
		Options FollowSymLinks
		AllowOverride None
    Require all granted
	&amp;lt;/Directory&amp;gt;

  ProxyPass /api/ http://127.0.0.1:9999/api/
  ProxyPassReverse /api/ http://127.0.0.1:9999/api/
  ProxyPassReverseCookiePath / /api
	
	LogLevel warn

	CustomLog ${APACHE_LOG_DIR}/access.log combined
&amp;lt;/VirtualHost&amp;gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;同域代理&lt;/code&gt; 后，服务端和前端代码都不需要进行修改，完美的解决了问题。最后还要说明的一点是：跨域请求被拒绝是在浏览器(客户端)上进行的，并不是服务端。&lt;/p&gt;

&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/53996160&quot;&gt;所有人都应该知道的跨域及CORS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 01 Jun 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/06/01/domain-proxy/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/06/01/domain-proxy/</guid>
        
        <category>linux</category>
        
        
      </item>
    
  </channel>
</rss>
