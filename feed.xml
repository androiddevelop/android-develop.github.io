<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>小胖轩</title>
    <description>编码生涯的点点滴滴</description>
    <link>https://https://www.codeboy.me/</link>
    <atom:link href="https://https://www.codeboy.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 06 May 2019 17:50:47 +0800</pubDate>
    <lastBuildDate>Mon, 06 May 2019 17:50:47 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>剪切板同步</title>
        <description>&lt;p&gt;工作中有两台主机，系统上一台macOS，一台Ubuntu，macOS作为主力机，经常需要将复制文本同步，之前的方案是登陆两个不同的微信进行分享，不过每次都需要打开，比较麻烦。&lt;/p&gt;

&lt;p&gt;有没有什么办法能够解决 macOS 到 Ubuntu 的单向文本复制呢？单向解决了，双向基本也没有问题，鉴于作者没有双向需求，故本文只介绍 macOS 到 Ubuntu 的单项文本同步方案,。目前可行的方案有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方案&lt;/th&gt;
      &lt;th&gt;优缺点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;IM、飞鸽传书&lt;/td&gt;
      &lt;td&gt;支持双向、操作流程略长&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;剪切板同步软件&lt;/td&gt;
      &lt;td&gt;支持双向，多平台支持不够，很多没有Linux&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SSH&lt;/td&gt;
      &lt;td&gt;支持双向，多平台支持，配置稍微复杂，使用方便&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;本次采用外能的 ssh 进行剪切板同步，考虑到不希望把 macOS 上的剪切板全部同步，只需要同步需要的即可，结合 macOS 上另外一个神器 &lt;code&gt;alfred&lt;/code&gt; 进行。&lt;/p&gt;

&lt;h3 id=&quot;一同步方案&quot;&gt;一、同步方案&lt;/h3&gt;
&lt;p&gt;macOS上操作剪切板非常的简单，&lt;code&gt;pbcopy&lt;/code&gt; 和 &lt;code&gt;pbpaste&lt;/code&gt; 分别对应复制和剪切，操作示例如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;➜  ~ echo &quot;Hello Codeboy&quot; | pbcopy 
➜  ~ pbpaste
Hello Codeboy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux上需要安装 &lt;code&gt;xclip&lt;/code&gt; 来完成，操作示例如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;➜  ~ echo &quot;Hello Codeboy&quot; |  xclip -in -selection clipboard
➜  ~ xclip -o                                              
Hello Codeboy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于 &lt;code&gt;xclip&lt;/code&gt; 牵扯图形操作，不能直接使用ssh在远程主机上执行命令完成，我们使用文件进行内容传输即可，接收方定时检查文件是否有更新，有更新的话使用 &lt;code&gt;xclip&lt;/code&gt; 同步到剪切板。
同时Ubuntu上需要配置 macOS 中 ssh 公钥，可以免密登陆，具体操作可以查询。&lt;/p&gt;

&lt;h3 id=&quot;二发送方macos&quot;&gt;二、发送方(macOS)&lt;/h3&gt;

&lt;p&gt;我们使用 &lt;code&gt;alfred&lt;/code&gt;中的workflow自定义快捷键执行脚本，操作如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新建空白workflow&lt;/li&gt;
  &lt;li&gt;添加Triggers –&amp;gt; HotKey, 定义喜欢的按键，作者选择(alt+F)，和复制键距离比较近。&lt;/li&gt;
  &lt;li&gt;新建Action –&amp;gt; Run Script, 输入复制脚本即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 将剪切板内容写入文件
pbpaste &amp;gt; /tmp/clip_content
# 发送到目标主机
scp -q /tmp/clip_content user@host:/tmp/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样需要复制的时候，&lt;code&gt;ctrl-C&lt;/code&gt; 后再次按下 &lt;code&gt;alt-F&lt;/code&gt; 即可发送。&lt;/p&gt;

&lt;h3 id=&quot;三接收方ubuntu&quot;&gt;三、接收方(Ubuntu)&lt;/h3&gt;

&lt;p&gt;接收方监听 &lt;code&gt;/tmp/clip_content&lt;/code&gt; 文件内容变化即可，脚本如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
last_content=&quot;&quot;
while true
do
 content=`cat /tmp/clip_content`
 if [ &quot;$content&quot; != &quot;$last_content&quot; ]
    then
      echo $content;
      xclip -in -selection clipboard &amp;lt; /tmp/clip_content
      last_content=&quot;$content&quot;
 fi
 sleep 1
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每秒钟检测该文件内容是否改变，改变的话复制到剪切板中，实时性还是很高的。打开终端，执行起来即可。&lt;/p&gt;

&lt;h3 id=&quot;四使用&quot;&gt;四、使用&lt;/h3&gt;

&lt;p&gt;macOS上遇到需要复制的文本，&lt;code&gt;ctrl-C --&amp;gt; alt-F&lt;/code&gt; 后, 切换到Ubuntu，直接粘贴即可。有更快捷的方式欢迎留言。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 17 Apr 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/04/17/clipboard-sync/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/04/17/clipboard-sync/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>零点时间</title>
        <description>&lt;p&gt;在一些按天计算的场景中，需要获取当天凌晨零点的时间，有什么快捷高效的做法呢？下面针对Java中的几种计算方式进行比较：&lt;/p&gt;

&lt;h4 id=&quot;1-simpledateformat&quot;&gt;1. SimpleDateFormat&lt;/h4&gt;

&lt;p&gt;获取当前时间对应的年月日，反向计算即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static long getTimeWay1() {
    try {
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.CHINA);
        return sdf.parse(sdf.format(System.currentTimeMillis())).getTime();
    } catch (ParseException e) {
        e.printStackTrace();
    }
    return -1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;2-calendar&quot;&gt;2. Calendar&lt;/h4&gt;

&lt;p&gt;使用 &lt;code&gt;java.util.Calendar&lt;/code&gt; 类，可以便捷去除时分秒以及毫秒的数值，&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static long getTimeWay2() {
    Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
    //注意，这里不是Calendar.HOUR, 需要按照24小时的Calendar.HOUR_OF_DAY进行
    calendar.set(Calendar.HOUR_OF_DAY, 0);
    calendar.set(Calendar.MINUTE, 0);
    calendar.set(Calendar.SECOND, 0);
    calendar.set(Calendar.MILLISECOND, 0);
    return calendar.getTimeInMillis();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;3-除法&quot;&gt;3. 除法&lt;/h4&gt;

&lt;p&gt;借鉴 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 的方式，本次直接使用除法操作即可，需要注意一点的是时区问题，东八区相对于零时区增加了八个小时，处理中需要处理一下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static long getTimeWay3() {
    long ONE_DAY = 24 * 3600 * 1000;
    long now = System.currentTimeMillis();
    long offset = TimeZone.getDefault().getRawOffset();
    return (now + offset) / ONE_DAY * ONE_DAY - offset;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方式&lt;/th&gt;
      &lt;th&gt;性能&lt;/th&gt;
      &lt;th&gt;使用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SimpleDateFormat&lt;/td&gt;
      &lt;td&gt;一般&lt;/td&gt;
      &lt;td&gt;一般&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Calendar&lt;/td&gt;
      &lt;td&gt;高&lt;/td&gt;
      &lt;td&gt;方便&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;除法&lt;/td&gt;
      &lt;td&gt;最高&lt;/td&gt;
      &lt;td&gt;时区问题需要注意&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对比下来, 推荐使用第二种&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 13 Apr 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/04/13/java-today-zero-hour/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/04/13/java-today-zero-hour/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>Zip几点小知识</title>
        <description>&lt;h2 id=&quot;问题来源&quot;&gt;问题来源&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;zip怎么加速解压速度？&lt;/li&gt;
  &lt;li&gt;相同文件分别压缩为 &lt;code&gt;a.zip&lt;/code&gt;  和 &lt;code&gt;b.zip&lt;/code&gt; 后，计算出的md5一样么？原因是？&lt;/li&gt;
  &lt;li&gt;zip文件的时间是怎么计算的？ (二进制上是怎么计算的)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;1-zip怎么加速解压速度&quot;&gt;1. zip怎么加速解压速度&lt;/h2&gt;

&lt;p&gt;为什么会有这个问题，源于近来项目中有一些cache包下发到手机中，需要解压，但是在一些中低端手机上，解压速度非常的慢，在一些算法求解中，常见的方式是使用空间换时间，zip中可行么？答案是可行的，看一下zip的几个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-nohighlight&quot;&gt;-0   store only 不压缩
-1   compress faster 最快压缩，压缩率最差。
-9   compress better 最大压缩，压缩率最佳。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;0-9之间代表不同的压缩率，可以使用 &lt;code&gt;-0&lt;/code&gt; 参数进行无损压缩，换句话说，即简单的将文件进行拼接即可。 对一个6.4M的js、css资源按照0、1、9压缩后，大小分别是5.7M、2.4M、2.1M，在手机解压速度测试中时间大幅度减少。&lt;/p&gt;

&lt;h2 id=&quot;2-相同文件压缩后的zip的md5值是否相同&quot;&gt;2. 相同文件压缩后的zip的md5值是否相同&lt;/h2&gt;

&lt;p&gt;一直有个疑问，对同一个文件进行压缩，一次压缩结果为 &lt;code&gt;1.zip&lt;/code&gt;, 另外一次是 &lt;code&gt;2.zip&lt;/code&gt;, 计算两个文件的md5，会是一样的么？ 先说一下结果，可能一样，也可能不一样，首先文件名对md5的结果没有影响，然后前后手动压缩一个文本文件，查看两个文件的二进制，发现只有一个字节不同，第一感觉大家应该都会想到是时间问题，确实是时间的改变造成了2个文件的差异，zip结构中有个 &lt;code&gt;Extra Filed&lt;/code&gt;，里面记录了文件上次修改和上次访问时间，当对文件进行第一次压缩时，文件的访问时间可能会被修改，因为该时间计算单位是秒，所以在脚本执行的情况下，会出现以下结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;➜  zip ./a.sh 
adding: hello.txt (stored 0%)
MD5 (h1.zip) = a277a7f05ca3cba3eb119424068aad95
adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = cd8924673f41e81b585a809df8e6b714
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = 5b69e56cc533d19c14c1aa234bd7d6e3
  adding: hello.txt (stored 0%)
MD5 (h1.zip) = 5b69e56cc533d19c14c1aa234bd7d6e3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，md5 会随着时间的偏移改变。在计算文件差异的时候，经常不需要关系此种信息，我们可以使用 &lt;code&gt;-X&lt;/code&gt; 参数去除extra属性。&lt;/p&gt;

&lt;h2 id=&quot;3-zip文件的时间计算&quot;&gt;3. zip文件的时间计算&lt;/h2&gt;

&lt;p&gt;研究了下zip文件的格式，在 &lt;strong&gt;Local file header&lt;/strong&gt; 中有一个对应的文件修改日期和修改时间字段，分别为2个字节，如下(小端模式下，读取时需要倒序):&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Offset&lt;/th&gt;
      &lt;th&gt;字符&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;50 4b 03 04&lt;/td&gt;
      &lt;td&gt;头部魔数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0a 00&lt;/td&gt;
      &lt;td&gt;版本 (10)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;00 00&lt;/td&gt;
      &lt;td&gt;标记, 加密与否&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;00 00&lt;/td&gt;
      &lt;td&gt;压缩算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;89 aa&lt;/td&gt;
      &lt;td&gt;最近修改时间 (这个)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;71 4e&lt;/td&gt;
      &lt;td&gt;最近修改日期 (这个)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;2d 3b 08 af&lt;/td&gt;
      &lt;td&gt;crc-32&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;0c 00 00 00&lt;/td&gt;
      &lt;td&gt;压缩大小，12B (12)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;22&lt;/td&gt;
      &lt;td&gt;0c 00 00 00&lt;/td&gt;
      &lt;td&gt;未压缩大小，12B&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;26&lt;/td&gt;
      &lt;td&gt;09 00&lt;/td&gt;
      &lt;td&gt;文件名字长度 (9)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;28&lt;/td&gt;
      &lt;td&gt;1c 00&lt;/td&gt;
      &lt;td&gt;扩展区域长度 (28)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;文件内容&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;最近修改时间&quot;&gt;最近修改时间&lt;/h4&gt;

&lt;p&gt;aa89 = 10101 010100 01001 =  21:20:09&lt;/p&gt;

&lt;h4 id=&quot;最近修改日期&quot;&gt;最近修改日期&lt;/h4&gt;

&lt;p&gt;4e71 = 0100111 0011 10001 = 39-03-17(年+1980) = 2019-03-17&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://adoyle.me/blog/why-zip-file-checksum-changed.html&quot;&gt;http://adoyle.me/blog/why-zip-file-checksum-changed.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://opensource.apple.com/source/zip/zip-6/unzip/unzip/proginfo/extra.fld&quot;&gt;https://opensource.apple.com/source/zip/zip-6/unzip/unzip/proginfo/extra.fld&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Wed, 20 Mar 2019 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2019/03/20/zip-tricks/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2019/03/20/zip-tricks/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>Andorid AsyncTask解析</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;AsyncTask 在Android开发中是一个经常用到的类，允许用户在工作线程上完成后台计算等任务，之后将结果同步UI线程，比起 Thread 和  Handler 模型使用起来方便一些。&lt;/p&gt;

&lt;p&gt;AsyncTask 使用起来如此方便了，那么有什么需要注意的问题么？看一段AsyncTask官网的介绍文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When first introduced, AsyncTasks were executed serially on a single background thread. Starting with Build.VERSION_CODES.DONUT, this was changed to a pool of threads allowing multiple tasks to operate in parallel. Starting with Build.VERSION_CODES.HONEYCOMB, tasks are executed on a single thread to avoid common application errors caused by parallel execution.

If you truly want parallel execution, you can invoke executeOnExecutor(java.util.concurrent.Executor, Object[]) with THREAD_POOL_EXECUTOR.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出，从 Android1.6 到  Android2.2 之间，AsyncTask是并行执行的，从HONEYCOMB(2.3)开始，为了避免并行执行造成的通用应用错误，任务的执行方式修改为串行。&lt;/p&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;

&lt;p&gt;我们从最新的Android 8.0中分析一下AsyncTask：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/**
 * An {@link Executor} that can be used to execute tasks in parallel.
 */
public static final Executor THREAD_POOL_EXECUTOR;

static {
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
            sPoolWorkQueue, sThreadFactory);
    threadPoolExecutor.allowCoreThreadTimeOut(true);
    THREAD_POOL_EXECUTOR = threadPoolExecutor;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AsyncTask中定义了一个线程池，在我们执行execute(params)的时候的操作如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@MainThread
public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; execute(Params... params) {
    return executeOnExecutor(sDefaultExecutor, params);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@MainThread
public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; executeOnExecutor(Executor exec,
        Params... params) {
    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task is already running.&quot;);
            case FINISHED:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task has already been executed &quot;
                        + &quot;(a task can be executed only once)&quot;);
        }
    }

    mStatus = Status.RUNNING;

	//之前前的准备工作
    onPreExecute();

    mWorker.mParams = params;
    //真正添加任务并执行
    exec.execute(mFuture);

    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中Executor传递了一个sDefaultExecutor，sDefaultExecutor的定义如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;
public static final Executor SERIAL_EXECUTOR = new SerialExecutor();
//串行执行器
private static class SerialExecutor implements Executor {
    final ArrayDeque&amp;lt;Runnable&amp;gt; mTasks = new ArrayDeque&amp;lt;Runnable&amp;gt;();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        //将任务加入队列中
        mTasks.offer(new Runnable() {
            public void run() {
                try {
                    r.run();
                } finally {
                    scheduleNext();
                }
            }
        });
        //如果首次添加，执行任务
        if (mActive == null) {
            scheduleNext();
        }
    }

    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里应该比较明确了，默认的executor使用的 SerialExecutor，而 SerialExecutor 的 execute 中的逻辑也很简单，直接添加队列，如果第一次添加的话，从队列中取出一个任务执行，进而达到了串行执行的结果。&lt;/p&gt;

&lt;p&gt;到此，AsyncTask 为什么串行执行已经分析完毕。&lt;/p&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;

&lt;p&gt;当前主流的应用，如手机淘宝、支付宝等的最低支持版本均已经是4.0，所以在开发中，系统的默认的AsyncTask的执行时串行的，我们可以进行修改。上面分析中也有提到，在AsyncTask执行execute方法的时候，使用了默认的Executor，我们可以使用AsyncTask中提供的另外一个方法 executeOnExecutor 指定线程池来执行，需要注意的一点是AsyncTask提供了线程池的 AsyncTask.THREAD_POOL_EXECUTOR ，我们可以使用这个线程池，但是这个线程池的参数中的队列长度是128，线程池拒绝策略采用的 AbortPolicy  ，任务超出线程池可承受范围(MAXIMUM_POOL_SIZE + POOL_SIZE)时，将会发生异常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));
private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
private static final int KEEP_ALIVE_SECONDS = 30;

//线程池队列
private static final BlockingQueue&amp;lt;Runnable&amp;gt; sPoolWorkQueue =
        new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(128);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们使用这个线程池，添加了比较多的耗时任务，将会crash，测试代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package me.codeboy.test;

import android.os.AsyncTask;
import android.os.Bundle;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;

import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class MainActivity extends AppCompatActivity {
    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();
    private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));
    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;
    private static final int KEEP_ALIVE_SECONDS = 30;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);


        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,
                new LinkedBlockingDeque&amp;lt;&amp;gt;(128));
        for (int i = 0; i &amp;lt; 200; i++) {
            new AsyncTask&amp;lt;Integer, Void, Void&amp;gt;() {
                @Override
                protected void onPostExecute(Void aVoid) {
                    super.onPostExecute(aVoid);

                }

                @Override
                protected Void doInBackground(Integer... params) {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    if (params != null || params.length &amp;gt; 0) {
                        Log.e(MainActivity.this.getClass().getSimpleName(), &quot;&quot; + params[0]);
                    }
                    return null;
                }
            }.executeOnExecutor(threadPoolExecutor, i);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;错误信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
java.lang.RuntimeException: Unable to start activity ComponentInfo{me.codeboy.test/me.codeboy.test.MainActivity}: java.util.concurrent.RejectedExecutionException: Task android.os.AsyncTask$3@a1014c4 rejected from java.util.concurrent.ThreadPoolExecutor@2c4bfad[Running, pool size = 9, active threads = 9, queued tasks = 128, completed tasks = 0]
   at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2817)
   at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2892)
   at android.app.ActivityThread.-wrap11(Unknown Source:0)
   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1593)
   at android.os.Handler.dispatchMessage(Handler.java:105)
   at android.os.Looper.loop(Looper.java:164)
   at android.app.ActivityThread.main(ActivityThread.java:6541)
   at java.lang.reflect.Method.invoke(Native Method)
   at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)
   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767)
Caused by: java.util.concurrent.RejectedExecutionException: Task android.os.AsyncTask$3@a1014c4 rejected from java.util.concurrent.ThreadPoolExecutor@2c4bfad[Running, pool size = 9, active threads = 9, queued tasks = 128, completed tasks = 0]
   at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2078)
   at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:843)
   at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1389)
   at android.os.AsyncTask.executeOnExecutor(AsyncTask.java:651)
   at me.codeboy.test.MainActivity.onCreate(MainActivity.java:50)
   at android.app.Activity.performCreate(Activity.java:6975)
   at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1213)
   at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2770)
   at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2892) 
   at android.app.ActivityThread.-wrap11(Unknown Source:0) 
   at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1593) 
   at android.os.Handler.dispatchMessage(Handler.java:105) 
   at android.os.Looper.loop(Looper.java:164) 
   at android.app.ActivityThread.main(ActivityThread.java:6541) 
   at java.lang.reflect.Method.invoke(Native Method) 
   at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240) 
   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:767) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;避免的方法是可以将队列大小加大或者不限制大小，在不限制大小的时候，如果MAXIMUM_POOL_SIZE和CORE_POOL_SIZE不同，那么MAXIMUM_POOL_SIZE将失去意义。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sat, 04 Aug 2018 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2018/08/04/android-async-task/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2018/08/04/android-async-task/</guid>
        
        <category>android</category>
        
        
      </item>
    
      <item>
        <title>Linux命令之ln</title>
        <description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;这几天一直想更换下osx下用户家目录的名字，为什么要更换呢? 因为之前托同学帮忙买来mac的时候已经创建了用户，当时也懒，也没用过osx，所以就一直到现在了。公司里的电脑是另外一台Macbook Pro，每次有一些牵扯到绝对路径的脚本等内容使用时，都需要改动配置等，于是乎决定对自己这台mac进行家目录重命名，大概的操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;系统设置 --&amp;gt;  用户和组 --&amp;gt; 解锁左下角小锁 --&amp;gt; 右击列表中用户 --&amp;gt; 高级选项 --&amp;gt; 修改家目录
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于家目录的修改这里不做详细介绍， 网上有很多教程，不过请做好数据备份。路径修改后，希望能通过访问新的路径访问到原先家目录对应的文件，毕竟各种软件的配置等信息都还在，这时候就需要用上Linux中ln命令。&lt;/p&gt;

&lt;h2 id=&quot;ln命令简介&quot;&gt;ln命令简介&lt;/h2&gt;
&lt;p&gt;ln是link的缩写，可以用来创建软连接和硬连接，使用和特点如下：&lt;/p&gt;

&lt;h4 id=&quot;软链接&quot;&gt;软链接：&lt;/h4&gt;

&lt;p&gt;使用操作:	&lt;code&gt;ln -s source target&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;软链接以路径的形式存在, 类似于Windows操作系统中的快捷方式&lt;/li&gt;
  &lt;li&gt;软链接可以跨文件系统, 硬链接不可以&lt;/li&gt;
  &lt;li&gt;软链接可以对一个不存在的文件名进行链接&lt;/li&gt;
  &lt;li&gt;软链接可以对目录进行链接&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;硬链接&quot;&gt;硬链接：&lt;/h4&gt;

&lt;p&gt;使用操作:	&lt;code&gt;ln source target&lt;/code&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;硬链接以文件副本的形式存在, 但不占用实际空间。&lt;/li&gt;
  &lt;li&gt;不允许给目录创建硬链接&lt;/li&gt;
  &lt;li&gt;硬链接只有在同一个文件系统中才能创建&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;更多其他参数的使用，可以&lt;code&gt;man ln&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;

&lt;p&gt;既然家目录改变了，可以将新的家目录连接的旧的家目录即可解决问题&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ln -s old_home new_home
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;两台mac的家目录统一了，很多文件、项目等的配置不用做任何修改了，哈哈。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 07 Jan 2018 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2018/01/07/linux-command-ln/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2018/01/07/linux-command-ln/</guid>
        
        <category>java</category>
        
        
      </item>
    
      <item>
        <title>Shell下解析Json之jq</title>
        <description>&lt;p&gt;Json是一种轻量级的数据交换格式，简洁和清晰的层次结构使得Json成为理想的数据交换语言，易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。&lt;/p&gt;

&lt;p&gt;软件开发中经常会将对象序列化为Json，或者将对应的Json串反序列化为对象，在Android开发、服务端开发中都有很多库，如fastjson、gson等, 今天来看一下shell的json解析工具jq。&lt;/p&gt;

&lt;h3 id=&quot;一安装&quot;&gt;一、安装&lt;/h3&gt;
&lt;p&gt;jq的官网地址&lt;a href=&quot;https://github.com/stedolan/jq&quot;&gt;https://github.com/stedolan/jq&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-mac&quot;&gt;1. mac&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;brew install jq
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;mac下安装时可能会提示更新xcode，如提示请更新。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;2-linux&quot;&gt;2. linux&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;apt-get install jq
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;ubuntu以及衍生版本可以直接仓库安装， 其他的发行版也可以尝试仓库或者源码编译&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;二基本用法&quot;&gt;二、基本用法&lt;/h3&gt;
&lt;p&gt;解析json最常用的要数取值和获取数组长度操作了，给出一段常见的json，结合场景介绍下简单的使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;data&quot;: [
    &quot;张三&quot;,
    &quot;李四&quot;
  ],
  &quot;code&quot;: &quot;SUCCESS&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假定content代表上面的字符串。&lt;/p&gt;

&lt;p&gt;jq获取字段时的格式为&lt;code&gt;.字段名&lt;/code&gt;，例如获取code值时，操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $content | grep '.code'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取data的长度的格式如下&lt;code&gt;'length'&lt;/code&gt;,直接使用不加.的length即可，操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo $content | jq '.data|length'
echo $content | jq '.data' | jq 'length'
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;更加详细的文档可以参见 &lt;a href=&quot;https://stedolan.github.io/jq/manual/&quot;&gt;https://stedolan.github.io/jq/manual&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;三场景使用&quot;&gt;三、场景使用&lt;/h3&gt;
&lt;p&gt;获取&lt;a href=&quot;https://www.codeboy.me&quot;&gt;小胖轩&lt;/a&gt;博客中的文章列表，由于之前小胖轩网站中加入了博客搜索功能，有一个对应的文章索引&lt;a href=&quot;https://www.codeboy.me/search/cb-search.json&quot;&gt;https://www.codeboy.me/search/cb-search.json&lt;/a&gt;，我们需要做的操作如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 下载cb-search.json文件
2. 解析json文件，遍历文章列表
3. 输出文章标题列表
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用jq进行解析即可:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 获取codeboy.me中所有文章的标题

json=`curl -s &quot;https://www.codeboy.me/search/cb-search.json&quot;`;

#获取文章列表
list=`echo $json | jq '.data'`;

#获取文章长度
length=`echo $json | jq'.data|length' `;

# 解析data字段后，开始遍历每一项，取出标题
for index in `seq 0 $length`
do
	echo $list | jq &quot;.[$index].title&quot;;
done

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;四小结&quot;&gt;四、小结&lt;/h3&gt;
&lt;p&gt;shell下写脚本非常的方便快捷，有了jq，可以完成更丰富的操作。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 27 Nov 2017 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2017/11/27/command-jq/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2017/11/27/command-jq/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>正则表达式之非获取匹配</title>
        <description>&lt;p&gt;正则表达式是平时开发中经常用到的技巧，大部分时候我们需要的是判断字符串有没有含有固定的模式串，但是某些场景下需要使用非获取匹配，下面根据一种常见的情景:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;匹配所有含有 &lt;code&gt;app://page.cb/myPage?id=xxxx&lt;/code&gt;的地址，但是排除参数中携带&lt;code&gt;downgrade=true&lt;/code&gt;的地址。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;具体用几个例子说明一下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;原始地址: app://page.cb/myPage
匹配结果: no， id不存在

原始地址: app://page.cb/myPage?id=123456
匹配结果: yes

原始地址: app://page.cb/myPage?param=123456
匹配结果: no, id不存在

原始地址: app://page.cb/myPage?id=123456&amp;amp;downgrade=true
匹配结果: no, downgrade为true

原始地址: app://page.cb/myPage?id=123456&amp;amp;downgrade=false
匹配结果: yes

原始地址: app://page.cb/myPage?downgrade=false&amp;amp;id=123456
匹配结果: yes

原始地址: app://page.cb/myPage?downgrade=true&amp;amp;id=123456
匹配结果: no, downgrade为true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配所有不含&lt;code&gt;downgrade=true&lt;/code&gt;的&lt;code&gt;app://page.cb/myPage?id=xxxx&lt;/code&gt;地址，这里可以使用正则表达式的非获取匹配，下面介绍非获取匹配的两种:&lt;/p&gt;

&lt;h4 id=&quot;pattern&quot;&gt;(?!pattern)&lt;/h4&gt;

&lt;p&gt;非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。&lt;/p&gt;

&lt;h4 id=&quot;pattern-1&quot;&gt;(?&amp;lt;!pattern)&lt;/h4&gt;

&lt;p&gt;非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&amp;lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。&lt;/p&gt;

&lt;p&gt;根据非获取匹配的写法， 我们采用了正向否定查询，正则表达式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app:\/\/page.cb\/myPage\?(((?!downgrade=true).)*id=\d+((?!downgrade=true).)*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对其中的反向预查部分进行分割如下：&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;background-color:#B5EF79; font-weight: 700;&quot;&gt;app:\/\/page.cb\/myPage&lt;/span&gt;&lt;span style=&quot;background-color:#FDBE73; font-weight: 700;&quot;&gt;\?&lt;/span&gt;(&lt;span style=&quot;background-color:#77C5FD; font-weight: 700;&quot;&gt;((?!downgrade=true).)*&lt;/span&gt;&lt;span style=&quot;background-color:#B5EF79&quot;&gt;id=\d+&lt;/span&gt;&lt;span style=&quot;background-color:#77C5FD; font-weight: 700;&quot;&gt;((?!downgrade=true).)*&lt;/span&gt;)&lt;/p&gt;

&lt;p&gt;可以在&lt;a href=&quot;https://regex101.com/&quot;&gt;https://regex101.com&lt;/a&gt; 中尝试匹配。&lt;/p&gt;

&lt;p&gt;分析以上正则表达式，即 &lt;code&gt;id=\d+&lt;/code&gt; 的前后都不能含有 &lt;code&gt;downgrade=true&lt;/code&gt; ，其中 &lt;code&gt;((?!downgrade=true).)*&lt;/code&gt; 从里到外看，&lt;code&gt;(?!downgrade=true)&lt;/code&gt; 代表不含该字符串，然后.用于匹配id参数前后的其他参数,此处的.不能防止在 &lt;code&gt;(?!downgrade=true)&lt;/code&gt; 的前面，会造成如果第一个参数是 &lt;code&gt;downgrade=true&lt;/code&gt; 时被遗漏掉。&lt;/p&gt;

&lt;p&gt;如果需要url中参数部分，其中$1即为参数部分。&lt;/p&gt;

&lt;p&gt;测试case集合：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;app://page.cb/myPage
app://page.cb/myPage?id=123456
app://page.cb/myPage?param=123456
app://page.cb/myPage?id=123456&amp;amp;downgrade=true
app://page.cb/myPage?id=123456&amp;amp;downgrade=false
app://page.cb/myPage?downgrade=false&amp;amp;id=123456
app://page.cb/myPage?downgrade=true&amp;amp;id=123456
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;由于各种语言对正则表达式支持程度不同，例如非获取匹配中的反向否定预查在javascript中不支持，但是在php,python,java中是支持的，正向否定预查在javascript,php,python,java中都支持，所以使用前一定要注意，同事需要考虑正则表达式的性能问题。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Sun, 01 Oct 2017 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2017/10/01/regex-trick/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2017/10/01/regex-trick/</guid>
        
        <category>trick</category>
        
        
      </item>
    
      <item>
        <title>Chrome内容保存插件 - Just One File</title>
        <description>&lt;p&gt;随着互联网的发展，当前我们可以方便的在网站中找到各种各样的资源，尽管现在网络已经无处不在，但是有些时候我们仍然需要保存一些信息到本地，于是开发一个Chrome插件的想法产生了。&lt;/p&gt;

&lt;h2 id=&quot;初衷&quot;&gt;初衷&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;所见即所存&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;目前很多网站都是动态产生的，而浏览器保存的是网页源码， 看到的和保存的内容是可能不一样的，特别是在没有网络的情况下打开。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;去除无用信息&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;很多网站页面中充满了广告等不相关的元素，这些元素影响了信息的查看，去除了后将提升阅读体验。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;针对第一个问题，可以直接保存浏览器当前的dom树，这样就可以达到所见即所存了。&lt;/li&gt;
  &lt;li&gt;针对第二个问题，目前像chrome等浏览器已经可以非常方便的操作dom中的元素了，删除、增加、修改都可以快速的完成。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实施&quot;&gt;实施&lt;/h2&gt;
&lt;p&gt;有了思路后，就可以根据Chrome插件开发的步骤开始制作插件了，考虑到动画等动态性的内容并不是那么的重要，所以在保存页面的时候，去除了所有引入的js和js代码，这样做的另一个好处是减少文件大小。&lt;/p&gt;

&lt;h2 id=&quot;后续&quot;&gt;后续&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;目前尚未对引入的css进行合并，直接注入到页面中，可以完全不依赖网络，下个版本改进。&lt;/li&gt;
  &lt;li&gt;保留一些动画等元素。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;下载&quot;&gt;下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/just-one-file/opofajlgipfljhhlfhcpmhhjckjaacia?hl=zh-CN&amp;amp;authuser=1&quot;&gt;https://chrome.google.com/webstore/detail/just-one-file/opofajlgipfljhhlfhcpmhhjckjaacia?hl=zh-CN&amp;amp;authuser=1&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 30 May 2017 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2017/05/30/chrome-plugin-for-save/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2017/05/30/chrome-plugin-for-save/</guid>
        
        <category>web</category>
        
        
      </item>
    
      <item>
        <title>深入浅出单实例Singleton模式</title>
        <description>&lt;p&gt;单实例Singleton设计模式可能是被讨论和使用的最广泛的一个设计模式了，这可能也是面试中问得最多的一个设计模式了。这个设计模式主要目的是想在整个系统中只能出现一个类的实例。这样做当然是有必然的，比如你的软件的全局配置信息，或者是一个Factory，或是一个主控类等等。&lt;/p&gt;

&lt;p&gt;本文会带着你深入整个Singleton的世界,下面从几个版本来进行分析。&lt;/p&gt;

&lt;h3 id=&quot;1-singleton教学版本&quot;&gt;1. Singleton教学版本&lt;/h3&gt;

&lt;p&gt;这里直接给出一个Singleton的简单实现，我们姑且把这个版本叫做1.0版，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.0
public class Singleton {
    private static Singleton singleton = null;
    
    private Singleton() {
    }
    
    public static Singleton getInstance() {
        if (singleton== null) {
            singleton= new Singleton();
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的实例中，我想说明下面几个Singleton的特点：（下面这些东西可能是尽人皆知的，没有什么新鲜的）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;私有（private）的构造函数，表明这个类是不可能形成实例了。这主要是怕这个类会有多个实例。&lt;/li&gt;
  &lt;li&gt;即然这个类是不可能形成实例，那么，我们需要一个静态的方式让其形成实例：getInstance()。注意这个方法是在new自己，因为其可以访问私有的构造函数，所以他是可以保证实例被创建出来的。&lt;/li&gt;
  &lt;li&gt;在getInstance()中，先做判断是否已形成实例，如果已形成则直接返回，否则创建实例。&lt;/li&gt;
  &lt;li&gt;所形成的实例保存在自己类中的私有成员中。&lt;/li&gt;
  &lt;li&gt;我们取实例时，只需要使用Singleton.getInstance()就行了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，如果你觉得知道了上面这些事情后就学成了，那得给你当头棒喝一下了，事情远远没有那么简单。&lt;/p&gt;

&lt;h3 id=&quot;2-singleton实际版本&quot;&gt;2. Singleton实际版本&lt;/h3&gt;

&lt;p&gt;上面的这个程序存在比较严重的问题，因为是全局性的实例，所以，在多线程情况下，所有的全局共享的东西都会变得非常的危险，这个也一样，在多线程情况下，如果多个线程同时调用getInstance()的话，那么，可能会有多个进程同时通过 (singleton== null)的条件检查，于是，多个实例就创建出来，并且很可能造成内存泄露问题。嗯，熟悉多线程的你一定会说——“我们需要线程互斥或同步”，没错，我们需要这个事情，于是我们的Singleton升级成1.1版，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.1
public class Singleton {
    private static Singleton singleton = null;
    
    private Singleton() {
    }
    
    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                singleton = new Singleton();
            }
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嗯，使用了Java的synchronized方法，看起来不错哦。应该没有问题了吧？！错！这还是有问题！为什么呢？前面已经说过，如果有多个线程同时通过(singleton== null)的条件检查（因为他们并行运行），虽然我们的synchronized方法会帮助我们同步所有的线程，让我们并行线程变成串行的一个一个去new，那不还是一样的吗？同样会出现很多实例。嗯，确实如此！看来，还得把那个判断(singleton== null)条件也同步起来。于是，我们的Singleton再次升级成1.2版本，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.2
public class Singleton {
    private static Singleton singleton = null;
    
    private Singleton()  {
    }
    
    public static Singleton getInstance()  {
        synchronized (Singleton.class) {
            if (singleton == null) {
               singleton = new Singleton();
            }
         }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不错不错，看似很不错了。在多线程下应该没有什么问题了，不是吗？的确是这样的，1.2版的Singleton在多线程下的确没有问题了，因为我们同步了所有的线程。只不过嘛……，什么？！还不行？！是的，还是有点小问题，我们本来只是想让new这个操作并行就可以了，现在，只要是进入getInstance()的线程都得同步啊，注意，创建对象的动作只有一次，后面的动作全是读取那个成员变量，这些读取的动作不需要线程同步啊。这样的作法感觉非常极端啊，为了一个初始化的创建动作，居然让我们达上了所有的读操作，严重影响后续的性能啊！&lt;/p&gt;

&lt;p&gt;还得改！嗯，看来，在线程同步前还得加一个(singleton== null)的条件判断，如果对象已经创建了，那么就不需要线程的同步了。OK，下面是1.3版的Singleton：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.3
public class Singleton {
    private static Singleton singleton = null;
    
    private Singleton()  {
    }
    
    public static Singleton getInstance() {
        if (singleton == null)  {
            synchronized (Singleton.class) {
                if (singleton == null)  {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;感觉代码开始变得有点罗嗦和复杂了，不过，这可能是最不错的一个版本了，这个版本又叫“双重检查”Double-Check。下面是说明：&lt;/p&gt;

&lt;p&gt;第一个条件是说，如果实例创建了，那就不需要同步了，直接返回就好了。
不然，我们就开始同步线程。
第二个条件是说，如果被同步的线程中，有一个线程创建了对象，那么别的线程就不用再创建了。
相当不错啊，干得非常漂亮！请大家为我们的1.3版起立鼓掌！&lt;/p&gt;

&lt;p&gt;但是，如果你认为这个版本大攻告成，你就错了。&lt;/p&gt;

&lt;p&gt;主要在于 &lt;code&gt;singleton = new Singleton()&lt;/code&gt; 这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给 singleton 分配内存&lt;/li&gt;
  &lt;li&gt;调用 Singleton 的构造函数来初始化成员变量，形成实例&lt;/li&gt;
  &lt;li&gt;将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null 了）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。&lt;/p&gt;

&lt;p&gt;对此，我们只需要把singleton声明成 volatile 就可以了。下面是1.4版：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.4
public class Singleton {
    private volatile static Singleton singleton = null;
    
    private Singleton()  {
    }
    
    public static Singleton getInstance()   {
        if (singleton == null)  {
            synchronized (Singleton.class) {
                if (singleton == null)  {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 volatile 有两个功用：&lt;/p&gt;

&lt;p&gt;1）这个变量不会在多个线程中存在复本，直接从内存读取。&lt;/p&gt;

&lt;p&gt;2）这个关键字会禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。&lt;/p&gt;

&lt;p&gt;但是，这个事情仅在Java 1.5版后有用，1.5版之前用这个变量也有问题，因为老版本的Java的内存模型是有缺陷的。&lt;/p&gt;

&lt;h3 id=&quot;3-singleton简化版本&quot;&gt;3. Singleton简化版本&lt;/h3&gt;

&lt;p&gt;上面的玩法实在是太复杂了，一点也不优雅，下面是一种更为优雅的方式：&lt;/p&gt;

&lt;p&gt;这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.5
public class Singleton {
    private volatile static Singleton singleton = new Singleton();
    
    private Singleton()  {
    }
    
    public static Singleton getInstance()   {
        return singleton;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，这种玩法的最大问题是——当这个类被加载的时候，new Singleton() 这句话就会被执行，就算是getInstance()没有被调用，类也被初始化了。&lt;/p&gt;

&lt;p&gt;于是，这个可能会与我们想要的行为不一样，比如，我的类的构造函数中，有一些事可能需要依赖于别的类干的一些事（比如某个配置文件，或是某个被其它类创建的资源），我们希望他能在我第一次getInstance()时才被真正的创建。这样，我们可以控制真正的类创建的时刻，而不是把类的创建委托给了类装载器。&lt;/p&gt;

&lt;p&gt;好吧，我们还得绕一下：&lt;/p&gt;

&lt;p&gt;下面的这个1.6版是老版《Effective Java》中推荐的方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// version 1.6
public class Singleton {
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    private Singleton (){
    }
    
    public static final Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这种方式，仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它只有在getInstance()被调用时才会真正创建；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。&lt;/p&gt;

&lt;h3 id=&quot;4-singleton优雅版本&quot;&gt;4. Singleton优雅版本&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public enum Singleton{
   INSTANCE;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;居然用枚举！！看上去好牛逼，通过EasySingleton.INSTANCE来访问，这比调用getInstance()方法简单多了。&lt;/p&gt;

&lt;p&gt;默认枚举实例的创建是线程安全的，所以不需要担心线程安全的问题。但是在枚举中的其他任何方法的线程安全由程序员自己负责。还有防止上面的通过反射机制调用私用构造器。&lt;/p&gt;

&lt;p&gt;这个版本基本上消除了绝大多数的问题。代码也非常简单，实在无法不用。这也是新版的《Effective Java》中推荐的模式。&lt;/p&gt;

&lt;h3 id=&quot;5-其他&quot;&gt;5. 其他&lt;/h3&gt;

&lt;p&gt;Singleton的其它问题可以从原文中查看。&lt;/p&gt;

&lt;p&gt;转载自&lt;a href=&quot;http://coolshell.cn/articles/265.html&quot;&gt;http://coolshell.cn/articles/265.html&lt;/a&gt;的部分,作者陈浩，本文进行了轻微改动。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 07 Feb 2017 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2017/02/07/head-first-singleton/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2017/02/07/head-first-singleton/</guid>
        
        <category>java</category>
        
        <category>pattern</category>
        
        
      </item>
    
      <item>
        <title>Hexo search组件</title>
        <description>&lt;p&gt;当前主流的静态博客有Jekyll和Hexo，之前的文章已经介绍了Jekyll中的搜索组件&amp;lt;&lt;a href=&quot;/2016/01/18/jekyll-search-component/&quot;&gt;Jekyll search组件&lt;/a&gt;&amp;gt;,本文来介绍下hexo博客中怎么添加搜索组件，组件项目地址&lt;a href=&quot;https://github.com/androiddevelop/hexo-search&quot;&gt;https://github.com/androiddevelop/hexo-search&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;截图&quot;&gt;截图&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/jekyll-search.jpg&quot; alt=&quot;jekyll-search.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;双击ctrl或者点击右下角搜索图标查看效果&lt;/p&gt;

&lt;h3 id=&quot;操作&quot;&gt;操作&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;点击右下角图标进行搜索&lt;/li&gt;
  &lt;li&gt;双击ctrl键进行搜索或关闭&lt;/li&gt;
  &lt;li&gt;搜索页面点击右上角关闭按钮关闭搜索试图&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;加入步骤&quot;&gt;加入步骤&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装搜索插件:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; npm install hexo-search-data-plugin --save
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将search目录放至于hexo主题的&lt;code&gt;source&lt;/code&gt;文件夹下，其中search目录结构如下:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt; search
 ├── cb-footer-add.html
 ├── css
 │   └── cb-search.css
 ├── img
 │   ├── cb-close.png
 │   └── cb-search.png
 └── js
     ├── bootstrap3-typeahead.min.js
     └── cb-search.js
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在当前主题的&lt;code&gt;layout/_partial/after-footer.ejs&lt;/code&gt; 中的末尾加入 &lt;code&gt;cb-footer-add.html&lt;/code&gt; 中的内容即可, 添加完毕后 &lt;code&gt;cb-footer-add.html&lt;/code&gt; 文件可以删除。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果主题不存在&lt;code&gt;after-footer.ejs&lt;/code&gt;文件，也可以添加在&lt;code&gt;footer.ejs&lt;/code&gt;中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;注意事项&quot;&gt;注意事项&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;bootstrap3-typeahead.min.js&lt;/code&gt; 的引入必须在&lt;code&gt;jquery.min.js&lt;/code&gt;引入之后!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;默认联想8个，如果需要更多的话，请检索 &lt;code&gt;bootstrap3-typeahead.min.js&lt;/code&gt; 中的&lt;strong&gt;items:8&lt;/strong&gt;, 将&lt;strong&gt;8&lt;/strong&gt;替换成自己需要的数值。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;如有任何知识产权、版权问题或理论错误，还请指正。&lt;/p&gt;

  &lt;p&gt;转载请注明原作者及以上信息。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 29 Nov 2016 00:00:00 +0800</pubDate>
        <link>https://https://www.codeboy.me/2016/11/29/hexo-search-component/</link>
        <guid isPermaLink="true">https://https://www.codeboy.me/2016/11/29/hexo-search-component/</guid>
        
        <category>web</category>
        
        
      </item>
    
  </channel>
</rss>
